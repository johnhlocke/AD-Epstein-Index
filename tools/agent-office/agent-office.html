<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Office</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
/* ── Reset & Base ── */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --gold: #f5c842;
  --gold-dark: #8B6914;
  --bg-dark: #1a1a28;
  --bg-darker: #111118;
  --bg-panel: #1a0e2e;
  --border: #333;
  --border-subtle: #2a2a3a;
  --text: #e0e0e0;
  --text-dim: #888;
  --text-muted: #555;
  --scout-color: #e74c3c;
  --courier-color: #3498db;
  --reader-color: #2ecc71;
  --detective-color: #9b59b6;
  --editor-color: #f5c842;
  --designer-color: #e91e63;
  --researcher-color: #e67e22;
}

body {
  font-family: 'Press Start 2P', monospace;
  background: var(--bg-dark);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  image-rendering: pixelated;
}

/* ══════════════════════════════════════
   3-COLUMN DASHBOARD GRID
   ══════════════════════════════════════ */
.dashboard {
  display: grid;
  grid-template-columns: 1.2fr 2fr 1.3fr;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "top    top    top"
    "left   center right";
  width: 1920px;
  height: 1080px;
  gap: 0;
  transform-origin: top left;
}

/* ── Top Bar ── */
.top-bar {
  grid-area: top;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  background: linear-gradient(180deg, rgba(245,200,66,0.08) 0%, transparent 100%);
  border-bottom: 2px solid var(--border);
}
.top-bar-title {
  font-size: 14px;
  color: var(--gold);
  text-shadow: 1px 1px 0 var(--gold-dark);
  letter-spacing: 3px;
  white-space: nowrap;
}

/* ── Scene Stats Overlay (over brick wall) ── */
.scene-stats-overlay {
  position: absolute;
  bottom: 16px;
  left: 8px;
  right: 8px;
  z-index: 10;
  display: flex;
  gap: 3px;
  pointer-events: none;
  transform: scale(0.92);
  transform-origin: bottom center;
}
.top-stat {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1px;
  padding: 3px 2px;
  background: rgba(0,0,0,0.6);
  border: 1px solid rgba(245,200,66,0.25);
  backdrop-filter: blur(4px);
  pointer-events: auto;
}
.top-stat-value {
  font-size: 12px;
  color: var(--gold);
  text-align: center;
}
.top-stat-label {
  font-size: 6px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
}
.top-stat.has-details {
  cursor: context-menu;
  border-color: rgba(245,200,66,0.5);
}
.top-stat.has-details:hover {
  border-color: var(--gold);
  background: rgba(245,200,66,0.08);
}

/* ── Left Panel ── */
.panel-left {
  grid-area: left;
  background: var(--bg-panel);
  border-right: 2px solid var(--border);
  overflow: hidden;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ── Center (Office Scene) ── */
.center-scene {
  grid-area: center;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  background: var(--bg-darker);
  image-rendering: pixelated;
}

/* ── Right Panel ── */
.panel-right {
  grid-area: right;
  background: var(--bg-panel);
  border-left: 2px solid var(--border);
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ── Panel Section ── */
.panel-section {
  flex-shrink: 0;
  min-width: 0;
  overflow: hidden;
}
.panel-section h3 {
  font-size: 9px;
  color: var(--gold);
  letter-spacing: 1px;
  margin-bottom: 10px;
  text-transform: uppercase;
  border-bottom: 1px solid var(--border-subtle);
  padding-bottom: 6px;
}

/* ══════════════════════════════════════
   LEFT PANEL — PIPELINE FUNNEL
   ══════════════════════════════════════ */
.pipeline-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.pipeline-bar-wrap {
  flex: 1;
  height: 12px;
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border-subtle);
  overflow: hidden;
}
.pipeline-bar {
  height: 100%;
  transition: width 0.6s ease;
}
.pipeline-count {
  font-size: 9px;
  color: var(--text);
  min-width: 32px;
  text-align: right;
}
.pipeline-label {
  font-size: 7px;
  color: var(--text-dim);
  min-width: 72px;
}

/* ══════════════════════════════════════
   LEFT PANEL — QUEUE DEPTHS
   ══════════════════════════════════════ */
.queue-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
  font-size: 7px;
}
.queue-dot {
  width: 8px;
  height: 8px;
  border-radius: 0;
  flex-shrink: 0;
}
.queue-count {
  color: var(--text);
  min-width: 24px;
  text-align: right;
  font-size: 9px;
}
.queue-label {
  color: var(--text-dim);
  font-size: 7px;
}

/* ══════════════════════════════════════
   LEFT PANEL — EDITOR INBOX
   ══════════════════════════════════════ */
.inbox-scroll {
  flex: 1;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #333 transparent;
}
.inbox-scroll::-webkit-scrollbar { width: 4px; }
.inbox-scroll::-webkit-scrollbar-track { background: transparent; }
.inbox-scroll::-webkit-scrollbar-thumb { background: #333; }
.inbox-msg {
  padding: 5px 7px;
  margin-bottom: 4px;
  background: rgba(245,200,66,0.04);
  border-left: 3px solid var(--gold-dark);
  font-size: 10px;
  line-height: 1.6;
}
.inbox-msg.alert {
  border-left-color: #e74c3c;
  background: rgba(231,76,60,0.06);
}
.inbox-msg-time {
  color: var(--text-muted);
  font-size: 9px;
  margin-bottom: 2px;
}
.inbox-msg-text {
  color: var(--text);
}
.inbox-msg.human {
  border-left-color: #3498db;
  background: rgba(52,152,219,0.06);
}
.inbox-msg.human .inbox-msg-time::before {
  content: 'YOU  ';
  color: #3498db;
}
.inbox-msg.reply {
  border-left-color: #f5c842;
  background: rgba(245,200,66,0.10);
}
.inbox-msg.reply .inbox-msg-time::before {
  content: 'MIRANDA  ';
  color: #f5c842;
}
.inbox-msg.reply .inbox-msg-text {
  color: #f5c842;
}
.inbox-empty {
  font-size: 6px;
  color: var(--text-dim);
  padding: 4px 0;
}
.inbox-input-wrap {
  display: flex;
  gap: 4px;
  padding-top: 10px;
  margin-top: auto;
  border-top: 1px solid var(--border-subtle);
  flex-shrink: 0;
}
.inbox-input {
  flex: 1;
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  padding: 8px 10px;
  background: rgba(0,0,0,0.4);
  border: 1px solid var(--border-subtle);
  color: var(--text);
  outline: none;
}
.inbox-input:focus {
  border-color: var(--gold);
}
.inbox-input::placeholder {
  color: var(--text-muted);
  font-size: 8px;
}
.inbox-send {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  padding: 8px 12px;
  background: rgba(245,200,66,0.12);
  border: 1px solid var(--gold-dark);
  color: var(--gold);
  cursor: pointer;
  flex-shrink: 0;
  transition: background 0.2s;
}
.inbox-send:hover {
  background: rgba(245,200,66,0.25);
}

/* ══════════════════════════════════════
   LEFT PANEL — NEWSROOM CHATTER
   ══════════════════════════════════════ */
.chatter-scroll {
  max-height: 120px;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #333 transparent;
}
.chatter-scroll::-webkit-scrollbar { width: 3px; }
.chatter-scroll::-webkit-scrollbar-track { background: transparent; }
.chatter-scroll::-webkit-scrollbar-thumb { background: #333; }
.chatter-note {
  padding: 3px 6px;
  margin-bottom: 2px;
  font-size: 9px;
  line-height: 1.5;
  border-left: 2px solid transparent;
  opacity: 0.85;
}
.chatter-note:hover { opacity: 1; }
.chatter-agent {
  font-weight: bold;
  margin-right: 4px;
}
.chatter-text { color: var(--text-muted); }
.chatter-note[data-agent="scout"] { border-left-color: #27ae60; }
.chatter-note[data-agent="scout"] .chatter-agent { color: #27ae60; }
.chatter-note[data-agent="courier"] { border-left-color: #3498db; }
.chatter-note[data-agent="courier"] .chatter-agent { color: #3498db; }
.chatter-note[data-agent="reader"] { border-left-color: #9b59b6; }
.chatter-note[data-agent="reader"] .chatter-agent { color: #9b59b6; }
.chatter-note[data-agent="detective"] { border-left-color: #e67e22; }
.chatter-note[data-agent="detective"] .chatter-agent { color: #e67e22; }
.chatter-note[data-agent="researcher"] { border-left-color: #e74c3c; }
.chatter-note[data-agent="researcher"] .chatter-agent { color: #e74c3c; }
.chatter-note[data-agent="editor"] { border-left-color: #f5c842; }
.chatter-note[data-agent="editor"] .chatter-agent { color: #f5c842; }
.chatter-note[data-agent="designer"] { border-left-color: #e91e63; }
.chatter-note[data-agent="designer"] .chatter-agent { color: #e91e63; }
.chatter-note .chatter-tag {
  font-size: 7px;
  padding: 1px 3px;
  border-radius: 2px;
  margin-left: 4px;
  opacity: 0.6;
}
.chatter-tag.warning { background: rgba(231,76,60,0.2); color: #e74c3c; }
.chatter-tag.discovery { background: rgba(46,204,113,0.2); color: #2ecc71; }
.chatter-tag.tip { background: rgba(52,152,219,0.15); color: #3498db; }
.chatter-tag.chatter { display: none; /* personality chatter needs no tag badge */ }
.chatter-empty { font-size: 8px; color: var(--text-dim); padding: 4px 0; }
.watercooler-convo {
  margin-bottom: 6px;
  padding: 4px 6px;
  background: rgba(245,200,66,0.06);
  border: 1px solid rgba(245,200,66,0.15);
  border-radius: 3px;
}
.watercooler-header {
  font-size: 7px;
  color: var(--gold-dark);
  margin-bottom: 3px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.watercooler-line {
  font-size: 9px;
  line-height: 1.5;
  padding: 1px 0;
}
.watercooler-line .wc-speaker {
  font-weight: bold;
  margin-right: 3px;
}
.chatter-toggle { cursor: pointer; user-select: none; }
.chatter-toggle:hover { color: var(--gold); }
#chatter-arrow { font-size: 7px; opacity: 0.5; transition: transform 0.2s; display: inline-block; }
#chatter-section.collapsed #chatter-arrow { transform: rotate(-90deg); }
#chatter-section.collapsed .chatter-scroll { display: none; }

/* ══════════════════════════════════════
   LEFT PANEL — AGENT NETWORK DIAGRAM
   ══════════════════════════════════════ */
.agent-network {
  position: relative;
  width: 100%;
  height: 340px;
}
.agent-network svg {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 0;
}
.network-line {
  stroke: rgba(255,255,255,0.06);
  stroke-width: 0.4;
  fill: none;
  transition: stroke 0.4s, stroke-width 0.4s;
}
.network-line.active {
  stroke-width: 0.4;
  stroke-dasharray: 2 1.5;
  animation: dash-flow 1.2s linear infinite;
}
@keyframes dash-flow {
  to { stroke-dashoffset: -7; }
}
.network-node {
  position: absolute;
  text-align: center;
  width: 110px;
  transform: translateX(-50%);
  z-index: 1;
  transition: opacity 0.3s, filter 0.3s, border-color 0.3s;
  padding: 5px 8px;
  border: 1px solid rgba(255,255,255,0.1);
  background: rgba(0,0,0,0.75);
}
.network-node.idle { opacity: 0.45; }
.network-node.active {
  opacity: 1;
  border-color: var(--agent-glow, rgba(255,255,255,0.2));
  background: rgba(0,0,0,0.85);
  filter: drop-shadow(0 0 6px var(--agent-glow, rgba(255,255,255,0.15)));
}
.network-node.network-editor .network-role {
  font-size: 11px;
  letter-spacing: 1.5px;
}
.network-role {
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 1px;
  line-height: 1.2;
}
.network-name {
  font-size: 6.5px;
  color: var(--text-dim);
  margin-top: 1px;
  letter-spacing: 0.3px;
}
.network-dot {
  width: 5px;
  height: 5px;
  border-radius: 0;
  margin: 3px auto 0;
}
.network-dot.active {
  animation: dot-pulse 1.2s infinite;
  box-shadow: 0 0 4px currentColor;
}
.network-task {
  font-size: 6px;
  color: var(--text-muted);
  margin-top: 3px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
  line-height: 1.4;
}

/* ══════════════════════════════════════
   RIGHT PANEL — ACTIVITY LOG
   ══════════════════════════════════════ */
.log-filters {
  display: flex;
  gap: 3px;
  margin-bottom: 6px;
}
.log-filter-btn {
  flex: 1;
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  padding: 5px 4px;
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border-subtle);
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}
.log-filter-btn:hover { color: var(--text); border-color: var(--text-dim); }
.log-filter-btn.active { color: var(--gold); border-color: var(--gold-dark); background: rgba(245,200,66,0.08); }

.log-scroll {
  max-height: 200px;
  overflow-y: auto;
}
.log-entry {
  font-size: 7px;
  padding: 4px 0;
  border-bottom: 1px solid #1e1e2e;
  display: flex;
  gap: 8px;
  line-height: 1.6;
}
.log-entry:last-child { border-bottom: none; }
.log-time { color: var(--text-muted); flex-shrink: 0; width: 48px; }
.log-agent { flex-shrink: 0; width: 56px; margin-left: 4px; }
.log-event { color: #aaa; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ══════════════════════════════════════
   RIGHT PANEL — CURRENT LEADS
   ══════════════════════════════════════ */
.find-card {
  padding: 6px 8px;
  margin-bottom: 5px;
  background: rgba(255,255,255,0.02);
  border-left: 3px solid #555;
  transition: all 0.4s ease;
}
.find-card.epstein_match { border-left-color: #e74c3c; background: rgba(231,76,60,0.06); }
.find-card.epstein_match.new-find { animation: findPulse 1.5s ease 2; }
@keyframes findPulse {
  0%, 100% { background: rgba(231,76,60,0.06); }
  50% { background: rgba(231,76,60,0.18); }
}
.find-name {
  font-size: 8px;
  color: var(--text);
  margin-bottom: 3px;
}
.find-card.epstein_match .find-name::before { content: '\26A0 '; color: #e74c3c; }
.find-meta {
  font-size: 7px;
  color: var(--text-dim);
}
/* ── Find Pipeline (DET → RES → EDT) ── */
.find-pipeline {
  display: flex;
  gap: 3px;
  align-items: center;
  margin-top: 4px;
}
.pipe-stage {
  font-size: 6px;
  display: flex;
  align-items: center;
  gap: 2px;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.pipe-stage-label {
  font-size: 5px;
  color: var(--text-muted);
}
.pipe-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  border: 1px solid currentColor;
  flex-shrink: 0;
}
.pipe-dot.complete { background: currentColor; }
.pipe-dot.active { animation: pipePulse 1.5s ease infinite; }
@keyframes pipePulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(0.8); }
}
.pipe-arrow {
  font-size: 6px;
  color: var(--text-dim);
  margin: 0 1px;
}
.pipe-arrow.dim { opacity: 0.2; }
.pipe-verdict {
  font-size: 5px;
  letter-spacing: 0.3px;
}

/* Data Quality panel removed — space reclaimed for Knowledge Graph */

/* ══════════════════════════════════════
   RIGHT PANEL — DISCOVERY COVERAGE MAP
   ══════════════════════════════════════ */
.coverage-grid {
  display: grid;
  grid-template-columns: 28px repeat(12, 1fr);
  gap: 1px;
  font-size: 5px;
}
.coverage-month-header {
  text-align: center;
  color: var(--text-dim);
  font-size: 5px;
  padding: 1px 0;
}
.coverage-year-label {
  text-align: right;
  padding-right: 3px;
  color: var(--text-dim);
  font-size: 5px;
  line-height: 7px;
}
.coverage-cell {
  width: 100%;
  height: 6px;
  background: #e74c3c;
  opacity: 0.6;
  border: 1px solid rgba(255,255,255,0.02);
}
.coverage-cell.discovered { background: #f1c40f; opacity: 0.7; }
.coverage-cell.downloaded, .coverage-cell.downloading { background: #f1c40f; opacity: 0.85; }
.coverage-cell.extracted { background: #2ecc71; opacity: 0.9; }
.coverage-cell.error, .coverage-cell.extraction_error { background: #e67e22; opacity: 0.6; }
.coverage-cell.skipped_pre1988 { background: rgba(255,255,255,0.08); opacity: 0.5; }
.coverage-cell.no_pdf { background: #e74c3c; opacity: 0.35; }
.coverage-legend {
  display: flex;
  gap: 8px;
  margin-top: 4px;
  font-size: 6px;
  color: var(--text-dim);
}
.coverage-legend-item {
  display: flex;
  align-items: center;
  gap: 3px;
}
.coverage-legend-swatch {
  width: 8px;
  height: 6px;
  display: inline-block;
}

/* ══════════════════════════════════════
   OFFICE SCENE — LAYERED SYSTEM
   ══════════════════════════════════════ */

.office-scene-wrapper {
  position: relative;
  width: 100%;
}

.office-scene {
  position: relative;
  width: 100%;
  aspect-ratio: 1888 / 2489;
  background: var(--bg-darker);
  overflow: hidden;
}

/* Layer 0: Room background */
.office-scene .layer-bg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  image-rendering: pixelated;
}

/* ── Overlay layers (positioned over the scene) ── */
.overlay-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  overflow: visible;
}

/* Layer 1: Chalkboard overlays (back wall) */
#chalkboard-layer { z-index: 1; pointer-events: none; }
#chalkboard-layer .chalkboard { pointer-events: auto; }

/* Layer 1.5: Back tables overlay (covers chalkboard panels) */
#back-tables-layer { z-index: 1; pointer-events: none; }

/* Layer 2: Mid-row desks (Scout, Courier) */
#desks-mid-layer { z-index: 2; overflow: hidden; }

/* Layer 3: Mid-row agents (Scout, Courier) */
#agents-mid-layer { z-index: 3; }
#agents-mid-layer .agent-char { pointer-events: auto; }

/* Layer 4: Front-row desks (Reader, Detective) */
#desks-front-layer { z-index: 4; overflow: hidden; }

/* Layer 5: Front-row agents (Reader, Detective) */
#agents-front-layer { z-index: 5; }
#agents-front-layer .agent-char { pointer-events: auto; }

/* Layer 6: Editor (roams the aisle — above most agents) */
#editor-layer { z-index: 6; }
#editor-layer .agent-char { pointer-events: auto; }

/* Layer 7: Bottom-row desk (Designer — overlaps Detective agent for depth) */
#desks-bottom-layer { z-index: 7; overflow: hidden; }

/* Layer 8: Bottom-row agent (Designer — highest agent z-index) */
#agents-bottom-layer { z-index: 8; }
#agents-bottom-layer .agent-char { pointer-events: auto; }

/* Layer 9: UI elements (speech bubbles, nametags) */
#ui-layer { z-index: 9; }

/* ══════════════════════════════════════
   CHALKBOARD TASK BOARDS (on back wall)
   ══════════════════════════════════════ */
.chalkboard {
  position: absolute;
  overflow: hidden;
  padding: 15px 10px 6px;
  font-family: 'Press Start 2P', monospace;
}
/* Left chalkboard replaced by Discovery Map overlay */
.coverage-overlay {
  position: absolute;
  left: calc(5% - 8px);
  top: calc(7.5% + 5px);
  width: 35.5%;
  height: 13.8%;
  overflow: hidden;
  padding: 8px 6px 3px;
  font-family: 'Press Start 2P', monospace;
  pointer-events: auto;
}
.coverage-overlay .chalk-title {
  margin-bottom: 2px;
  padding-bottom: 2px;
}
.coverage-overlay .coverage-grid {
  grid-template-columns: 16px repeat(12, 1fr);
  gap: 0px;
  font-size: 3px;
}
.coverage-overlay .coverage-cell {
  height: 3px;
  border: none;
}
.coverage-overlay .coverage-month-header {
  font-size: 3px;
  padding: 0;
  color: rgba(255,255,255,0.5);
}
.coverage-overlay .coverage-year-label {
  font-size: 3px;
  line-height: 3.5px;
  padding-right: 1px;
  color: rgba(255,255,255,0.45);
}
.coverage-overlay .coverage-legend {
  font-size: 3px;
  margin-top: 1px;
  gap: 3px;
  color: rgba(255,255,255,0.5);
}
.coverage-overlay .coverage-legend-swatch {
  width: 5px;
  height: 3px;
}
.chalkboard-right {
  left: 63%;
  top: 7.5%;
  width: 30.5%;
  height: 13.8%;
}
.cost-panel-overlay {
  position: absolute;
  left: 39.2%;
  top: 7.4%;
  width: 21.5%;
  height: 3.2%;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 1;
}
.cost-panel-value {
  font-family: 'Press Start 2P', monospace;
  font-size: 9px;
  color: #e04040;
  text-shadow: 0 0 6px rgba(224,64,64,0.5);
  letter-spacing: 1px;
}
.chalk-title {
  font-size: 5px;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-bottom: 4px;
  text-shadow: 0 0 4px rgba(255,255,255,0.3);
  text-align: center;
  border-bottom: 1px solid rgba(255,255,255,0.25);
  padding-bottom: 3px;
}
.chalk-list {
  overflow-y: auto;
  max-height: calc(100% - 18px);
}
.chalk-list::-webkit-scrollbar { width: 2px; }
.chalk-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); }
.chalk-item {
  display: flex;
  align-items: baseline;
  gap: 4px;
  padding: 2px 0;
  font-size: 4px;
  line-height: 1.6;
  color: #fff;
  text-shadow: 0 0 3px rgba(255,255,255,0.2);
  border-bottom: 1px solid rgba(255,255,255,0.1);
}
.chalk-item:last-child { border-bottom: none; }
.chalk-agent {
  flex-shrink: 0;
  min-width: 36px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.chalk-goal {
  color: rgba(255, 255, 255, 0.85);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.chalk-item.completed .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.completed .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-item.failed .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.failed .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-item.in-flight .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.exhausted .chalk-agent { color: rgba(255, 255, 255, 0.75); text-decoration: line-through; }
.chalk-item.exhausted .chalk-goal { color: rgba(255, 255, 255, 0.5); text-decoration: line-through; }
.chalk-item.stuck .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.stuck .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-section-label {
  font-size: 3.5px;
  color: rgba(255,255,255,0.45);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 3px 0 1px 0;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
.chalk-count {
  font-size: 3.5px;
  color: rgba(255,255,255,0.35);
  margin-left: auto;
  flex-shrink: 0;
}
.chalk-empty {
  font-size: 4px;
  color: rgba(255,255,255,0.6);
  text-align: center;
  padding: 8px 0;
  font-style: italic;
}

/* ── CSS Fallback Floor (no bg image) ── */
.office-floor {
  position: absolute;
  inset: 0;
}
.office-floor::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 48px),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 48px);
  background-color: #1e1e2e;
}
.corridor {
  position: absolute;
  left: 38%; width: 24%;
  top: 0; bottom: 0;
  background: rgba(255,255,255,0.02);
  border-left: 1px dashed rgba(255,255,255,0.06);
  border-right: 1px dashed rgba(255,255,255,0.06);
}
.door {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 48px; height: 8px;
  background: #5a3a1a;
  border-bottom: 2px solid #3a2510;
}
.door::after {
  content: 'DOOR';
  position: absolute;
  bottom: -14px; left: 50%;
  transform: translateX(-50%);
  font-size: 5px;
  color: rgba(255,255,255,0.15);
  font-family: 'Press Start 2P', monospace;
  white-space: nowrap;
}

/* ── Desk Overlay Images ── */
.desk-overlay {
  position: absolute;
  image-rendering: pixelated;
  pointer-events: none;
}
/* Bottom row — Designer & Researcher */
.desk-overlay[data-desk="designer"] {
  width: 25.92%;
  right: 10%;
  top: 66%;
}
.desk-overlay[data-desk="researcher"] {
  width: 27.78%;
  left: 9%;
  top: 71%;
}
/* Mid row — Scout & Courier */
.desk-overlay[data-desk="scout"] {
  width: 24%;
  left: 10%;
  top: 36%;
}
.desk-overlay[data-desk="courier"] {
  width: 28.51%;
  right: 6%;
  top: 34%;
}
/* Front row — Reader & Detective */
.desk-overlay[data-desk="reader"] {
  width: 24%;
  left: 10%;
  top: 52%;
}
.desk-overlay[data-desk="detective"] {
  width: 24%;
  right: 10%;
  top: 51%;
}

/* ── Agent Character ── */
.agent-char {
  position: absolute;
  transition: left 1.5s ease-in-out, top 1.5s ease-in-out;
  cursor: pointer;
}
/* Ground shadow under each agent */
.agent-char::after {
  content: '';
  position: absolute;
  bottom: -4px;
  left: 50%;
  transform: translateX(-50%);
  width: 60%;
  height: 12%;
  background: radial-gradient(ellipse, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.35) 50%, transparent 70%);
  border-radius: 50%;
  pointer-events: none;
}
/* Per-agent shadow fixes */
.agent-char[data-agent="reader"]::after {
  bottom: 2px;
  width: 75%;
  height: 15%;
}
.agent-char[data-agent="researcher"]::after {
  bottom: 6px;
}

/* Character images */
.char-img {
  height: 100%;
  width: auto;
  image-rendering: pixelated;
  display: block;
  margin: 0 auto;
}
.char-img.char-front { display: none; }
.char-img.char-back { display: block; }

/* When collaborating, show front */
.agent-char.show-front .char-front { display: block; }
.agent-char.show-front .char-back { display: none; }

/* Editor extra pose sprites (hidden by default) */
.char-img.char-blink,
.char-img.char-tap,
.char-img.char-watch,
.char-img.char-failure,
.char-img.char-clipboard,
.char-img.char-studying { display: none; }

/* ── Status Animations ── */
.agent-char.anim-idle .char-img {
  animation: idle-bob 2.5s ease-in-out infinite;
}
.agent-char.anim-working .char-img {
  animation: working-bounce 0.5s steps(2) infinite;
}
.agent-char.anim-done .char-img {
  animation: done-relax 3s ease-in-out infinite;
}
.agent-char.anim-error .char-img {
  animation: error-shake 0.4s ease-in-out infinite;
}

@keyframes idle-bob {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}
@keyframes working-bounce {
  0% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}
@keyframes done-relax {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-1px); }
}
@keyframes error-shake {
  0%, 100% { transform: translateY(0); }
  25% { transform: translateX(3px); }
  75% { transform: translateX(-3px); }
}

/* ── Particles ── */
.particle-container {
  position: absolute;
  top: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 20px;
  pointer-events: none;
  overflow: visible;
}
.particle {
  position: absolute;
  width: 4px; height: 4px;
  animation: particle-float 1.5s ease-out infinite;
}
.particle:nth-child(1) { left: 25%; animation-delay: 0s; }
.particle:nth-child(2) { left: 50%; animation-delay: 0.4s; }
.particle:nth-child(3) { left: 75%; animation-delay: 0.8s; }
.agent-char.anim-working .particle { background: rgba(255,255,255,0.5); }
.agent-char.anim-done .particle { background: #2ecc71; animation-duration: 2.5s; }
.agent-char.anim-error .particle { background: #e74c3c; animation-duration: 0.8s; }
.agent-char.anim-idle .particle { display: none; }

@keyframes particle-float {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-16px) scale(0.5); }
}

/* ── UI Elements (Speech Bubble + Nametag) ── */
.agent-ui {
  position: absolute;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Speech Bubble */
.speech-bubble {
  --bubble-bg: #fff;
  position: absolute;
  bottom: calc(100% + 6px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--bubble-bg);
  color: #222;
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  line-height: 1.6;
  padding: 6px 10px;
  white-space: normal;
  word-wrap: break-word;
  width: max-content;
  max-width: 280px;
  border: 2px solid #333;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease, background 0.3s ease;
  box-shadow: -2px 0 0 #333, 2px 0 0 #333, 0 -2px 0 #333, 0 2px 0 #333;
}
.speech-bubble::after {
  content: '';
  position: absolute;
  top: 100%; left: 50%;
  transform: translateX(-50%);
  width: 0; height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 6px solid var(--bubble-bg);
  filter: drop-shadow(0 2px 0 #333);
}
.speech-bubble.visible {
  opacity: 1;
  animation: bubble-pop 0.25s ease-out;
}

@keyframes bubble-pop {
  0% { transform: translateX(-50%) scale(0.7); opacity: 0; }
  100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

/* Agent Name Tag */
.agent-nametag {
  position: absolute;
  top: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  white-space: nowrap;
  padding: 2px 6px;
  background: rgba(0,0,0,0.8);
  border: 1px solid;
  pointer-events: none;
}

/* Cycle count + progress shown under nametag */
.agent-nametag .tag-stats {
  display: block;
  font-size: 4px;
  opacity: 0.7;
  margin-top: 1px;
  letter-spacing: 0;
}

/* Status Indicator Dot */
.status-dot {
  position: absolute;
  top: -4px;
  right: -4px;
  width: 8px; height: 8px;
  border: 1px solid rgba(0,0,0,0.5);
}
.status-dot.working { background: #27ae60; animation: dot-pulse 1s infinite; }
.status-dot.idle    { background: #555; }
.status-dot.done    { background: #f5c842; }
.status-dot.error   { background: #e74c3c; animation: dot-pulse 0.5s infinite; }

@keyframes dot-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ── Collaboration Glow — traces sprite silhouette in initiator's color ── */
.agent-char.collab-glow {
  filter:
    drop-shadow(0 0 1.5px var(--glow-color, #f5c842))
    drop-shadow(0 0 4px var(--glow-color, #f5c842))
    drop-shadow(0 0 7px var(--glow-color, #f5c842));
  animation: collab-glow-pulse 1.2s ease-in-out infinite;
}
@keyframes collab-glow-pulse {
  0%, 100% { opacity: 0.9; }
  50% { opacity: 1; }
}

/* ── Hub-and-Spoke: Working Agent (back view, pulsing agent-color outline) ── */
.agent-char.hub-working {
  filter:
    drop-shadow(0 0 2px var(--agent-color, #888))
    drop-shadow(0 0 5px var(--agent-color, #888));
  animation: hub-work-pulse 2s ease-in-out infinite;
}
.agent-char.hub-working .char-front { display: none !important; }
.agent-char.hub-working .char-back { display: block !important; }

@keyframes hub-work-pulse {
  0%, 100% { filter: drop-shadow(0 0 2px var(--agent-color, #888)) drop-shadow(0 0 5px var(--agent-color, #888)); }
  50% { filter: drop-shadow(0 0 3px var(--agent-color, #888)) drop-shadow(0 0 9px var(--agent-color, #888)); }
}

/* ── Hub-and-Spoke: Waiting Agent (front view, no glow) ── */
.agent-char.hub-waiting {
  filter: none;
}
.agent-char.hub-waiting .char-front { display: block !important; }
.agent-char.hub-waiting .char-back { display: none !important; }
.agent-char.hub-waiting .char-waiting { display: none !important; }

/* ── Hub-and-Spoke: Bored Agent (waiting sprite, no glow) ── */
.char-img.char-waiting { display: none; }
.agent-char.hub-bored {
  filter: none;
}
.agent-char.hub-bored .char-front { display: none !important; }
.agent-char.hub-bored .char-back { display: none !important; }
.agent-char.hub-bored .char-waiting { display: block !important; }

/* ── Hub-and-Spoke: Rest Agent (rest sprite, no glow — default idle for agents with rest sprite) ── */
.char-img.char-rest { display: none; }
.agent-char.hub-rest {
  filter: none;
}
.agent-char.hub-rest .char-front { display: none !important; }
.agent-char.hub-rest .char-back { display: none !important; }
.agent-char.hub-rest .char-waiting { display: none !important; }
.agent-char.hub-rest .char-rest { display: block !important; }

/* ── Hub-and-Spoke: Done Agent (relaxing sprite, subtle green glow) ── */
.char-img.char-done { display: none; }
.agent-char.hub-done {
  filter:
    drop-shadow(0 0 2px rgba(46, 204, 113, 0.4))
    drop-shadow(0 0 6px rgba(46, 204, 113, 0.2));
}
.agent-char.hub-done .char-front { display: none !important; }
.agent-char.hub-done .char-back { display: none !important; }
.agent-char.hub-done .char-waiting { display: none !important; }
.agent-char.hub-done .char-done { display: block !important; }

/* ── Hub-and-Spoke: Editor Engagement (yellow glow on both) ── */
.agent-char.editor-engage {
  filter:
    drop-shadow(0 0 4px #f5c842)
    drop-shadow(0 0 10px #f5c842)
    drop-shadow(0 0 18px #f5c842);
  animation: editor-engage-pulse 1s ease-in-out infinite;
}
@keyframes editor-engage-pulse {
  0%, 100% { opacity: 0.85; }
  50% { opacity: 1; }
}

/* ══════════════════════════════════════
   LIVE / STALE INDICATOR
   ══════════════════════════════════════ */
.live-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  font-size: 7px;
  letter-spacing: 1px;
  border: 1px solid;
  margin-left: 16px;
}
.live-badge .live-dot {
  width: 6px; height: 6px;
  border-radius: 0;
}
.live-badge.live {
  color: #27ae60;
  border-color: #27ae60;
}
.live-badge.live .live-dot {
  background: #27ae60;
  animation: dot-pulse 1s infinite;
}
.live-badge.stale {
  color: #f39c12;
  border-color: #f39c12;
}
.live-badge.stale .live-dot {
  background: #f39c12;
}
.live-badge.offline {
  color: #e74c3c;
  border-color: #e74c3c;
}
.live-badge.offline .live-dot {
  background: #e74c3c;
  animation: dot-pulse 0.5s infinite;
}

/* ══════════════════════════════════════
   AGENT ERROR OVERLAY
   ══════════════════════════════════════ */
.agent-char.has-error::before {
  content: '!';
  position: absolute;
  top: -10px;
  right: -4px;
  width: 16px; height: 16px;
  background: #e74c3c;
  color: #fff;
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20;
  animation: error-shake 0.4s ease-in-out infinite;
}
/* Error tooltip on hover */
.agent-char.has-error[data-error]::after {
  content: attr(data-error);
  position: absolute;
  top: -28px;
  left: 50%;
  transform: translateX(-50%);
  background: #e74c3c;
  color: #fff;
  font-family: 'Press Start 2P', monospace;
  font-size: 4px;
  line-height: 1.4;
  padding: 3px 6px;
  white-space: nowrap;
  max-width: 180px;
  overflow: hidden;
  text-overflow: ellipsis;
  z-index: 30;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
}
.agent-char.has-error[data-error]:hover::after {
  opacity: 1;
}
.agent-char.is-paused .char-img {
  filter: grayscale(60%) brightness(0.6);
}

/* ══════════════════════════════════════
   THROUGHPUT & COST SECTIONS
   ══════════════════════════════════════ */
.metric-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 5px;
  font-size: 7px;
}
.metric-label {
  color: var(--text-dim);
  min-width: 80px;
}
.metric-value {
  color: var(--text);
  font-size: 9px;
  text-align: right;
}
.metric-value.gold { color: var(--gold); }
.metric-value.green { color: #27ae60; }

/* ══════════════════════════════════════
   SKILLS MODAL
   ══════════════════════════════════════ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 100;
  display: none;
  align-items: center;
  justify-content: center;
}
.modal-overlay.visible {
  display: flex;
}
.modal {
  background: var(--bg-panel);
  border: 2px solid var(--gold-dark);
  width: 600px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}
.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-subtle);
}
.modal-title {
  font-size: 9px;
  color: var(--gold);
  letter-spacing: 1px;
}
.modal-close {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  background: none;
  border: 1px solid var(--border-subtle);
  color: var(--text-dim);
  padding: 4px 8px;
  cursor: pointer;
}
.modal-close:hover { color: var(--text); border-color: var(--text-dim); }
.modal-tabs {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--border-subtle);
  overflow-x: auto;
}
.modal-tab {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  padding: 8px 12px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--text-dim);
  cursor: pointer;
  white-space: nowrap;
}
.modal-tab:hover { color: var(--text); }
.modal-tab.active {
  color: var(--gold);
  border-bottom-color: var(--gold);
}
.modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}
.modal-body pre {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  line-height: 2;
  color: var(--text);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* ══════════════════════════════════════
   AGENT CONTROL BUTTONS (floating at cursor)
   ══════════════════════════════════════ */
.agent-controls-popup {
  position: fixed;
  display: none;
  flex-direction: column;
  gap: 6px;
  z-index: 200;
  pointer-events: auto;
  padding: 8px;
  background: rgba(0,0,0,0.92);
  border: 1px solid var(--gold-dark);
  max-width: 220px;
}
.agent-controls-popup.visible {
  display: flex;
}
.agent-popup-header {
  display: flex;
  flex-direction: column;
  gap: 3px;
  padding-bottom: 5px;
  border-bottom: 1px solid var(--border-subtle);
}
.agent-popup-name {
  font-size: 10px;
  color: var(--agent-color, var(--gold));
  letter-spacing: 1px;
}
.agent-popup-desc {
  font-size: 7px;
  color: var(--text-dim);
  line-height: 1.4;
}
.agent-popup-buttons {
  display: flex;
  gap: 6px;
}
.agent-ctrl-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  padding: 8px 14px;
  background: rgba(0,0,0,0.95);
  border: 2px solid var(--border-subtle);
  color: var(--text-dim);
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
}
.agent-ctrl-btn:hover {
  color: var(--gold);
  border-color: var(--gold-dark);
  background: rgba(245,200,66,0.12);
}
/* Button colors set dynamically via --agent-color */
.agent-ctrl-btn.pause-btn,
.agent-ctrl-btn.resume-btn,
.agent-ctrl-btn.skills-btn {
  border-color: var(--agent-color, #888);
  color: var(--agent-color, #888);
}
.agent-ctrl-btn:hover {
  background: color-mix(in srgb, var(--agent-color, #888) 15%, transparent);
}

/* ── Editor listening/happy sprite states ── */
.char-img.char-listen,
.char-img.char-happy { display: none; }

/* ── Sound Toggle ── */
.sound-toggle {
  position: fixed;
  bottom: 16px; right: 16px;
  z-index: 50;
  background: rgba(0,0,0,0.7);
  border: 2px solid var(--border);
  color: var(--text-dim);
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 5px 8px;
  cursor: pointer;
  transition: color 0.2s;
}
.sound-toggle:hover { color: var(--gold); }
.sound-toggle.active { color: #27ae60; border-color: #27ae60; }

/* ── Scrollbars ── */
.panel-left::-webkit-scrollbar,
.panel-right::-webkit-scrollbar,
.log-scroll::-webkit-scrollbar { width: 4px; }
.panel-left::-webkit-scrollbar-track,
.panel-right::-webkit-scrollbar-track,
.log-scroll::-webkit-scrollbar-track { background: transparent; }
.panel-left::-webkit-scrollbar-thumb,
.panel-right::-webkit-scrollbar-thumb,
.log-scroll::-webkit-scrollbar-thumb { background: #333; }

/* ── Toast Notifications ── */
.toast-container {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column-reverse;
  gap: 6px;
  pointer-events: none;
}
.toast {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  padding: 8px 16px;
  border: 1px solid;
  background: var(--bg-darker);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s, transform 0.3s;
  pointer-events: auto;
  white-space: nowrap;
}
.toast.visible { opacity: 1; transform: translateY(0); }
.toast.success { color: #27ae60; border-color: #27ae60; }
.toast.error { color: #e74c3c; border-color: #e74c3c; }
.toast.info { color: var(--gold); border-color: var(--gold-dark); }

/* ── Loading ── */
.loading {
  text-align: center;
  padding: 30px;
  font-size: 9px;
  color: var(--text-dim);
  animation: blink 1s steps(2) infinite;
}
@keyframes blink { 50% { opacity: 0; } }

/* ══════════════════════════════════════
   RESPONSIVE — Collapse to single column
   ══════════════════════════════════════ */
@media (max-width: 1024px) {
  .dashboard {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto auto;
    grid-template-areas:
      "top"
      "center"
      "left"
      "right";
    height: auto;
    overflow: auto;
  }
  body { overflow: auto; }
  .panel-left, .panel-right {
    border: none;
    border-top: 2px solid var(--border);
  }
  .center-scene {
    max-height: 60vh;
  }
  .top-bar { flex-wrap: wrap; }
  .top-bar-stats { flex-wrap: wrap; }
}
@media (max-width: 640px) {
  .top-bar-title { font-size: 8px; }
  .top-stat { padding: 3px 6px; }
  .top-stat-value { font-size: 9px; }
  .speech-bubble { font-size: 4px; max-width: 180px; }
}
/* ══════════════════════════════════════
   KNOWLEDGE GRAPH PANEL
   ══════════════════════════════════════ */
.graph-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  user-select: none;
}
.graph-panel-header h3 {
  margin-bottom: 0;
  padding-bottom: 6px;
}
.graph-toggle-icon {
  font-size: 7px;
  color: var(--text-dim);
  transition: transform 0.2s;
}
.graph-panel-header.collapsed .graph-toggle-icon {
  transform: rotate(-90deg);
}
#graph-container {
  width: 100%;
  height: 340px;
  border: 1px solid var(--border-subtle);
  background: var(--bg-panel);
  position: relative;
  overflow: hidden;
}
#graph-container canvas {
  image-rendering: auto;
}
.graph-stats-bar {
  display: flex;
  justify-content: space-between;
  font-size: 5px;
  color: var(--text-dim);
  padding: 4px 0 0;
  letter-spacing: 0.5px;
}
.graph-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  font-size: 6px;
  color: var(--text-dim);
  letter-spacing: 1px;
}
</style>
<script src="https://unpkg.com/force-graph@1.49.5/dist/force-graph.min.js"></script>
</head>
<body>

<div class="dashboard">
  <!-- ── Top Bar ── -->
  <div class="top-bar">
    <span class="top-bar-title" id="main-title">AGENT OFFICE</span>
    <div class="live-badge offline" id="live-badge">
      <div class="live-dot"></div>
      <span id="live-label">OFFLINE</span>
    </div>
  </div>

  <!-- ── Left Panel ── -->
  <div class="panel-left">
    <div class="panel-section" id="now-section">
      <h3>AGENT NETWORK</h3>
      <div id="now-content"></div>
    </div>
    <div class="panel-section" id="chatter-section">
      <h3 class="chatter-toggle" onclick="toggleChatter()">NEWSROOM CHATTER <span id="chatter-arrow">&#9660;</span></h3>
      <div class="chatter-scroll" id="chatter-content">
        <div class="chatter-empty">Agents haven't posted yet...</div>
      </div>
    </div>
    <div class="panel-section" id="inbox-section" style="flex:1;display:flex;flex-direction:column;min-height:0">
      <h3>EDITOR INBOX</h3>
      <div class="inbox-scroll" id="inbox-content"></div>
      <div class="inbox-input-wrap">
        <input type="text" class="inbox-input" id="inbox-input" placeholder="Message the Editor...">
        <button class="inbox-send" id="inbox-send">SEND</button>
      </div>
    </div>
  </div>

  <!-- ── Center — Office Scene ── -->
  <div class="center-scene">
    <!-- Stats overlay (bottom-aligned with editor message box) -->
    <div class="scene-stats-overlay" id="top-stats"></div>
    <div class="office-scene-wrapper">
      <div class="office-scene" id="office-scene">
        <!-- Layer 0: Room background -->
        <img class="layer-bg" id="room-bg" src="bg-office-clear-new.png?v=0ac04e47"
             onerror="this.style.display='none'">
        <!-- CSS fallback floor (hidden when bg loads) -->
        <div class="office-floor" id="fallback-floor">
          <div class="corridor"></div>
          <div class="door"></div>
        </div>
      </div>

      <!-- Layer 1: Chalkboard task boards (back wall) -->
      <div class="overlay-layer" id="chalkboard-layer">
        <div class="coverage-overlay" id="coverage-overlay">
          <div class="chalk-title">DISCOVERY MAP</div>
          <div id="coverage-content"></div>
        </div>
        <div class="cost-panel-overlay">
          <span class="cost-panel-value" id="cost-panel-value">$0.00</span>
        </div>
        <div class="chalkboard chalkboard-right" id="chalkboard-right">
          <div class="chalk-title">COMPLETED / FAILED</div>
          <div class="chalk-list" id="chalk-results"></div>
        </div>
      </div>

      <!-- Layer 1.5: Back tables overlay (on top of chalkboard panels) -->
      <div class="overlay-layer" id="back-tables-layer">
        <img src="bg-office-back-tables.png?v=21b82bf1"
             onerror="this.style.display='none'"
             style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;image-rendering:pixelated;">
      </div>

      <!-- Layer 2: Mid-row desks (Scout, Courier) -->
      <div class="overlay-layer" id="desks-mid-layer">
        <img class="desk-overlay" data-desk="scout" src="scout_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="courier" src="courier_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 3: Mid-row agent sprites (Scout, Courier) -->
      <div class="overlay-layer" id="agents-mid-layer"></div>

      <!-- Layer 4: Front-row desks (Reader, Detective) -->
      <div class="overlay-layer" id="desks-front-layer">
        <img class="desk-overlay" data-desk="reader" src="reader_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="detective" src="detective_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 5: Front-row agent sprites (Reader, Detective) -->
      <div class="overlay-layer" id="agents-front-layer"></div>

      <!-- Layer 6: Editor (roams the aisle freely) -->
      <div class="overlay-layer" id="editor-layer"></div>

      <!-- Layer 7: Bottom-row desks (Designer + Researcher) -->
      <div class="overlay-layer" id="desks-bottom-layer">
        <img class="desk-overlay" data-desk="researcher" src="researcher_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="designer" src="designer_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 8: Bottom-row agent (Designer — highest z-index) -->
      <div class="overlay-layer" id="agents-bottom-layer"></div>

      <!-- Layer 9: UI (speech bubbles + nametags) -->
      <div class="overlay-layer" id="ui-layer"></div>
    </div>
  </div>

  <!-- ── Right Panel ── -->
  <div class="panel-right">
    <div class="panel-section" id="graph-section">
      <div class="graph-panel-header" id="graph-panel-toggle">
        <h3>SUSPECTED NAMES KNOWLEDGE GRAPH</h3>
        <span class="graph-toggle-icon">&#9660;</span>
      </div>
      <div id="graph-panel-body">
        <div id="graph-container"><div class="graph-empty">Waiting for graph data...</div></div>
        <div class="graph-stats-bar">
          <span id="graph-stat-nodes">0 nodes</span>
          <span id="graph-stat-edges">0 edges</span>
          <span id="graph-stat-communities">0 communities</span>
        </div>
      </div>
    </div>
    <div class="panel-section" id="log-section">
      <h3>ACTIVITY LOG</h3>
      <div class="log-filters" id="log-filters"></div>
      <div class="log-scroll" id="log-scroll">
        <div id="log-entries"></div>
      </div>
    </div>
    <div class="panel-section" id="finds-section">
      <h3>CURRENT LEADS</h3>
      <div id="finds-content"></div>
    </div>
  </div>
</div>

<!-- Agent Controls Popup (shared, positioned at cursor) -->
<div class="agent-controls-popup" id="agent-controls-popup">
  <div class="agent-popup-header" id="ctrl-header">
    <div class="agent-popup-name" id="ctrl-name"></div>
    <div class="agent-popup-desc" id="ctrl-desc"></div>
  </div>
  <div class="agent-popup-buttons">
    <button class="agent-ctrl-btn pause-btn" id="ctrl-pause">PAUSE</button>
    <button class="agent-ctrl-btn resume-btn" id="ctrl-resume" style="display:none">RESUME</button>
    <button class="agent-ctrl-btn skills-btn" id="ctrl-skills">SKILLS</button>
  </div>
</div>

<!-- Skills Modal -->
<div class="modal-overlay" id="skills-modal">
  <div class="modal">
    <div class="modal-header">
      <span class="modal-title">AGENT SKILLS</span>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="modal-close" id="skills-edit-btn" style="color:var(--gold);border-color:var(--gold-dark)">EDIT</button>
        <button class="modal-close" id="skills-save-btn" style="display:none;color:#27ae60;border-color:#27ae60">SAVE</button>
        <button class="modal-close" id="skills-cancel-btn" style="display:none">CANCEL</button>
        <button class="modal-close" id="skills-modal-close">X</button>
      </div>
    </div>
    <div class="modal-tabs" id="skills-tabs"></div>
    <div class="modal-body">
      <pre id="skills-content">Select an agent to view their skills...</pre>
      <textarea id="skills-editor" style="display:none;width:100%;height:100%;min-height:400px;font-family:'Press Start 2P',monospace;font-size:7px;line-height:2;color:var(--text);background:rgba(0,0,0,0.3);border:1px solid var(--border-subtle);padding:12px;resize:none;outline:none"></textarea>
    </div>
    <div id="skills-save-status" style="display:none;padding:8px 16px;font-size:7px;border-top:1px solid var(--border-subtle)"></div>
  </div>
</div>

<div class="toast-container" id="toast-container"></div>
<button class="sound-toggle" id="sound-toggle" title="Toggle ambient sound">SFX OFF</button>

<script>
// ── Toast Notifications ──
function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('visible'));
  setTimeout(() => {
    toast.classList.remove('visible');
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// ── Configuration ──
const params = new URLSearchParams(window.location.search);
const STATUS_URL = params.get('status') || 'status.json';
const POLL_MS = parseInt(params.get('poll') || '2000', 10);
const FORCE_DEMO = params.get('demo') === 'true';

// ── Character Names ──
// Each agent has a personality name from their skills file
const AGENT_NAMES = {
  editor:     'Miranda',
  scout:      'Arthur',
  courier:    'Casey',
  reader:     'Elias',
  detective:  'Silas',
  researcher: 'Elena',
  designer:   'Sable',
};

// ── Agent Config ──
const AGENT_CONFIG = {
  editor: {
    homeX: 50, homeY: 86, exitX: 50,
    charHeight: 14,
    color: '#f5c842',
    row: 'editor',
  },
  designer: {
    homeX: 78, homeY: 80, exitX: 56,
    charHeight: 15.12,
    color: '#e91e63',
    row: 'bottom',
  },
  scout: {
    homeX: 22, homeY: 42, exitX: 44,
    charHeight: 15.12,
    color: '#e74c3c',
    row: 'mid',
  },
  courier: {
    homeX: 76, homeY: 42, exitX: 56,
    charHeight: 14,
    color: '#3498db',
    row: 'mid',
  },
  reader: {
    homeX: 22, homeY: 61, exitX: 44,
    charHeight: 12.88,
    color: '#2ecc71',
    row: 'front',
  },
  detective: {
    homeX: 78, homeY: 62, exitX: 56,
    charHeight: 14,
    color: '#9b59b6',
    row: 'front',
  },
  researcher: {
    homeX: 22, homeY: 79, exitX: 44,
    charHeight: 17.96,
    color: '#e67e22',
    row: 'bottom',
  },
};
const CORRIDOR_MEET_Y = 49;
// Chalkboard positions (where Editor stands when visiting boards)
const DISCOVERY_MAP_POS = { x: 20, y: 26 };  // Discovery Map (left overlay)
const BOARD_RIGHT_POS = { x: 80, y: 26 };   // Completed/Failed Board (right chalkboard)

// ── State ──
let currentState = null;
let previousState = null;
let agentCharElements = {};
let agentUIElements = {};
let imagesLoaded = { bg: false, chars: {} };
let activeCollaborations = [];
let typewriterTimers = {};
let audioCtx = null;
let soundOn = false;
let ambientOsc = null;
let activeLogFilter = 'All';
let agentWaitCycles = {};     // Per-agent counter of consecutive waiting poll cycles
let agentBoredThreshold = {}; // Per-agent randomized threshold before going bored
let editorBusy = false;
let mirandaCurrentSpeech = '...';
let editorBehaviorTimer = null;
let dataSource = 'demo'; // 'live', 'demo', 'offline'
let lastDataTimestamp = null;
let pendingHumanMessages = []; // Optimistic messages not yet in server data

// ── Knowledge Graph State ──
let graphInstance = null;      // force-graph instance
let lastGraphJSON = null;      // Change detection for graph data
let graphCollapsed = false;    // Collapsible panel state

// ── Image Asset Paths ──
const ASSETS = {
  bg: 'bg-office-clear-new.png?v=0ac04e47',
  chars: {
    editor:    { front: 'editor_front_trans.png', back: 'editor_back_trans.png',
                  blink: 'editor_front_blink_trans.png', tap: 'editor_front_tap_trans.png',
                  watch: 'editor_front_watch_trans.png',
                  listen: 'editor_front_listening_trans.png', happy: 'editor_front_happy_trans.png',
                  failure: 'editor_front_failure_trans.png', clipboard: 'editor_back_clipboard_trans.png',
                  studying: 'editor_front_studying_trans.png' },
    designer:  { front: 'designer_front_trans.png',  back: 'designer_back_trans.png',  waiting: 'designer_front_waiting_trans.png', rest: 'designer_front_rest_trans.png' },
    scout:     { front: 'scout_front_trans.png',     back: 'scout_back_trans.png',     waiting: 'scout_front_waiting_trans.png', done: 'scout_front_done_trans.png' },
    courier:   { front: 'courier_front_trans.png',   back: 'courier_back_trans.png',   waiting: 'courier_front_waiting_trans.png', done: 'courier_front_done_trans.png' },
    reader:    { front: 'reader_front_trans.png',    back: 'reader_back_trans.png',    waiting: 'reader_front_waiting_trans.png' },
    detective: { front: 'detective_front_trans.png',  back: 'detective_back_trans.png', waiting: 'detective_front_waiting_trans.png' },
    researcher: { front: 'researcher_front_trans.png', back: 'researcher_back_trans.png', waiting: 'researcher_front_waiting_trans.png' },
  },
};

// ── Initialize ──
function init() {
  initAgents();
  // Desk labels removed — agent names shown in right-click popup
  initBackground();
  initLogFilters();
  initEditorBehavior();
  initSkillsModal();
  initAgentControlsPopup();
  initKnowledgeGraph();
  fetchStatus();
  setInterval(fetchStatus, POLL_MS);
  setInterval(fetchGraphData, POLL_MS * 3); // Poll graph less often (6s)
  document.getElementById('sound-toggle').addEventListener('click', toggleSound);
  document.getElementById('inbox-send').addEventListener('click', sendInboxMessage);
  document.getElementById('inbox-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') sendInboxMessage();
  });
  // Track user scroll in inbox to avoid forced auto-scroll to top
  const inboxScroll = document.querySelector('.inbox-scroll') || document.getElementById('inbox-content');
  if (inboxScroll) {
    inboxScroll.addEventListener('scroll', function() {
      // User has scrolled away from top (reading older messages)
      this._userScrolled = this.scrollTop > 80;
    });
  }
}

function initBackground() {
  const bg = document.getElementById('room-bg');
  bg.onload = () => {
    imagesLoaded.bg = true;
    document.getElementById('fallback-floor').style.display = 'none';
  };
  bg.onerror = () => {
    bg.style.display = 'none';
  };
}

function initAgents() {
  const charsMidLayer = document.getElementById('agents-mid-layer');
  const charsFrontLayer = document.getElementById('agents-front-layer');
  const editorLayer = document.getElementById('editor-layer');
  const charsBottomLayer = document.getElementById('agents-bottom-layer');
  const uiLayer = document.getElementById('ui-layer');

  const ROW_LAYERS = {
    mid: charsMidLayer,
    front: charsFrontLayer,
    editor: editorLayer,
    bottom: charsBottomLayer,
  };

  for (const [id, cfg] of Object.entries(AGENT_CONFIG)) {
    // ── Character element ──
    const charEl = document.createElement('div');
    charEl.className = 'agent-char anim-idle';
    charEl.dataset.agent = id;
    charEl.style.left = cfg.homeX + '%';
    charEl.style.top = cfg.homeY + '%';
    charEl.style.height = cfg.charHeight + '%';
    charEl.style.transform = 'translate(-50%, -50%)';

    const backImg = document.createElement('img');
    backImg.className = 'char-img char-back';
    backImg.src = ASSETS.chars[id].back;
    backImg.alt = '';
    backImg.draggable = false;
    backImg.onerror = () => { backImg.style.display = 'none'; };
    charEl.appendChild(backImg);

    const frontImg = document.createElement('img');
    frontImg.className = 'char-img char-front';
    frontImg.src = ASSETS.chars[id].front;
    frontImg.alt = '';
    frontImg.draggable = false;
    frontImg.onerror = () => { frontImg.style.display = 'none'; };
    charEl.appendChild(frontImg);

    // Waiting/bored sprite (all worker agents)
    if (ASSETS.chars[id].waiting) {
      const waitImg = document.createElement('img');
      waitImg.className = 'char-img char-waiting';
      waitImg.src = ASSETS.chars[id].waiting;
      waitImg.alt = '';
      waitImg.draggable = false;
      waitImg.onerror = () => { waitImg.style.display = 'none'; };
      charEl.appendChild(waitImg);
    }

    // Rest sprite (agents with a resting/idle pose)
    if (ASSETS.chars[id].rest) {
      const restImg = document.createElement('img');
      restImg.className = 'char-img char-rest';
      restImg.src = ASSETS.chars[id].rest;
      restImg.alt = '';
      restImg.draggable = false;
      restImg.onerror = () => { restImg.style.display = 'none'; };
      charEl.appendChild(restImg);
    }

    // Done/relaxing sprite (agents that have completed their work)
    if (ASSETS.chars[id].done) {
      const doneImg = document.createElement('img');
      doneImg.className = 'char-img char-done';
      doneImg.src = ASSETS.chars[id].done;
      doneImg.alt = '';
      doneImg.draggable = false;
      doneImg.onerror = () => { doneImg.style.display = 'none'; };
      charEl.appendChild(doneImg);
    }

    // Editor gets extra pose sprites
    if (id === 'editor') {
      const extras = ASSETS.chars.editor;
      for (const [pose, src] of [['blink', extras.blink], ['tap', extras.tap], ['watch', extras.watch], ['listen', extras.listen], ['happy', extras.happy], ['failure', extras.failure], ['clipboard', extras.clipboard], ['studying', extras.studying]]) {
        const img = document.createElement('img');
        img.className = `char-img char-${pose}`;
        img.src = src;
        img.alt = '';
        img.draggable = false;
        img.onerror = () => { img.style.display = 'none'; };
        charEl.appendChild(img);
      }
      // Editor starts facing front (toward camera)
      charEl.classList.add('show-front');
    }

    const particles = document.createElement('div');
    particles.className = 'particle-container';
    particles.innerHTML = '<div class="particle"></div><div class="particle"></div><div class="particle"></div>';
    charEl.appendChild(particles);

    // Right-click agent to show controls popup
    charEl.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showAgentControlsPopup(id, e.clientX, e.clientY);
    });

    // Place agent in correct row layer
    const targetLayer = ROW_LAYERS[cfg.row] || charsBackLayer;
    targetLayer.appendChild(charEl);
    agentCharElements[id] = charEl;

    // ── UI element (Layer 4) ──
    const uiEl = document.createElement('div');
    uiEl.className = 'agent-ui';
    uiEl.dataset.agent = id;
    uiEl.style.left = cfg.homeX + '%';
    uiEl.style.top = cfg.homeY + '%';
    uiEl.style.height = cfg.charHeight + '%';
    uiEl.style.transform = 'translate(-50%, -50%)';
    uiEl.style.transition = 'left 1.5s ease-in-out, top 1.5s ease-in-out';

    const bubble = document.createElement('div');
    bubble.className = 'speech-bubble';
    bubble.id = `bubble-${id}`;
    uiEl.appendChild(bubble);

    const dot = document.createElement('div');
    dot.className = 'status-dot idle';
    dot.id = `dot-${id}`;
    uiEl.appendChild(dot);

    uiLayer.appendChild(uiEl);
    agentUIElements[id] = uiEl;

    charEl.addEventListener('click', () => {
      const b = document.getElementById(`bubble-${id}`);
      if (b) b.classList.toggle('visible');
    });
  }
}

// (Desk labels removed — agent identity shown in right-click popup)

// ── Log Filter Buttons ──
function initLogFilters() {
  const container = document.getElementById('log-filters');
  const filters = ['All', 'Miranda', 'Arthur', 'Casey', 'Elias', 'Silas', 'Elena', 'Sable'];
  filters.forEach(f => {
    const btn = document.createElement('button');
    btn.className = 'log-filter-btn' + (f === 'All' ? ' active' : '');
    btn.textContent = f;
    btn.addEventListener('click', () => {
      activeLogFilter = f;
      container.querySelectorAll('.log-filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderLogFiltered();
    });
    container.appendChild(btn);
  });
}

// ── Update Agent Visuals ──
function updateAgent(agentData) {
  const charEl = agentCharElements[agentData.id];
  const uiEl = agentUIElements[agentData.id];
  if (!charEl || !uiEl) return;

  const status = agentData.status || 'idle';

  // Error visibility — show error badge + tooltip on sprite
  if (agentData.errors > 0 && agentData.last_error) {
    charEl.classList.add('has-error');
    charEl.setAttribute('data-error', agentData.last_error);
  } else {
    charEl.classList.remove('has-error');
    charEl.removeAttribute('data-error');
  }

  // Paused visual
  if (agentData.paused) {
    charEl.classList.add('is-paused');
  } else {
    charEl.classList.remove('is-paused');
  }

  // Editor has custom behavior — only update bubble, dot & editor state
  if (agentData.id === 'editor') {
    const dot = document.getElementById('dot-editor');
    if (dot) dot.className = 'status-dot ' + status;
    const tag = document.getElementById('tag-editor');
    if (tag) tag.textContent = 'MIRANDA';

    // Track Miranda's current LLM-generated speech for animations to use
    mirandaCurrentSpeech = agentData.speech || agentData.liveTask || agentData.message || '...';

    // 1:1 editor state → sprite mapping
    const editorState = agentData.editor_state || 'idle';
    if (!editorBusy) {
      switch (editorState) {
        case 'listening':
          editorSetSprite('listen');
          break;
        case 'happy':
          editorSetSprite('happy');
          break;
        case 'assessing':
          editorSetSprite('studying');
          break;
        case 'monitoring':
          // Stay in current idle pose
          break;
      }
    }

    updateSpeechBubble('editor', mirandaCurrentSpeech);
    return;
  }

  // Hub-and-spoke: Working vs Waiting state
  charEl.className = charEl.className.replace(/\banim-\w+/g, '');
  // Only remove hub states if not in an editor-engage animation
  if (!charEl.classList.contains('editor-engage')) {
    charEl.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done', 'show-front');
  }

  const isWorking = status === 'working' && agentData.liveTask;
  const isError = status === 'error';
  const aid = agentData.id;
  // Personality speech takes priority over generic status messages
  const speechText = agentData.speech || agentData.liveTask || agentData.message;

  if (charEl.classList.contains('editor-engage')) {
    // During Editor engagement, keep front-facing + yellow glow, just update animation
    charEl.classList.add('anim-idle');
  } else if (isWorking) {
    // Working: face away (back view), pulsing colored outline
    charEl.classList.add('hub-working', 'anim-working');
    charEl.style.setProperty('--agent-color', AGENT_CONFIG[aid]?.color || '#888');
    updateSpeechBubble(aid, speechText);
    // Reset wait counter — agent is active
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else if (isError) {
    // Error: face camera, shake animation
    charEl.classList.add('show-front', 'anim-error');
    updateSpeechBubble(aid, agentData.speech || agentData.last_error || 'Error!');
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else if (status === 'done' && ASSETS.chars[aid]?.done) {
    // Done with a done sprite: show relaxing pose
    charEl.classList.add('hub-done', 'anim-done');
    updateSpeechBubble(aid, agentData.speech || agentData.message || '');
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else if (ASSETS.chars[aid]?.rest) {
    // Agent with rest sprite (e.g. Sable): show rest pose as default idle,
    // bored sprite still kicks in after threshold
    agentWaitCycles[aid] = (agentWaitCycles[aid] || 0) + 1;
    if (!agentBoredThreshold[aid]) {
      agentBoredThreshold[aid] = 3 + Math.floor(Math.random() * 4);
    }
    const cycles = agentWaitCycles[aid];
    const threshold = agentBoredThreshold[aid];
    const waitText = agentData.speech || '';

    if (cycles >= threshold) {
      // Alternate between rest and bored every 2-3 cycles
      const togglePeriod = 2 + (threshold % 2);
      const showBored = Math.floor((cycles - threshold) / togglePeriod) % 2 === 0;
      if (showBored) {
        charEl.classList.add('hub-bored', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      } else {
        charEl.classList.add('hub-rest', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      }
    } else {
      // Default idle: rest sprite
      charEl.classList.add('hub-rest', 'anim-idle');
      updateSpeechBubble(aid, waitText);
    }
  } else {
    // Waiting/Idle/Done (no done or rest sprite): increment wait counter
    agentWaitCycles[aid] = (agentWaitCycles[aid] || 0) + 1;
    // Randomized threshold per agent (3-6 cycles = 15-30s) — set once per wait period
    if (!agentBoredThreshold[aid]) {
      agentBoredThreshold[aid] = 3 + Math.floor(Math.random() * 4);
    }

    const cycles = agentWaitCycles[aid];
    const threshold = agentBoredThreshold[aid];
    // Use last personality speech — agents generate their own idle chatter
    const waitText = agentData.speech || '';

    if (cycles >= threshold) {
      // Alternate between front and bored every 2-3 cycles
      const togglePeriod = 2 + (threshold % 2); // varies per agent
      const showBored = Math.floor((cycles - threshold) / togglePeriod) % 2 === 0;
      if (showBored) {
        // Bored: show waiting/bored sprite
        charEl.classList.add('hub-bored', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      } else {
        // Brief return to front before going bored again
        charEl.classList.add('hub-waiting', 'show-front', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      }
    } else {
      // Not yet bored: normal front-facing wait
      charEl.classList.add('hub-waiting', 'show-front', 'anim-idle');
      updateSpeechBubble(aid, waitText);
    }
    // Keep waiting bubble persistently visible (override auto-hide)
    const waitBubble = document.getElementById(`bubble-${aid}`);
    if (waitBubble) waitBubble.classList.add('visible');
  }

  const dot = document.getElementById(`dot-${agentData.id}`);
  if (dot) dot.className = 'status-dot ' + status;

  const tag = document.getElementById(`tag-${agentData.id}`);
  if (tag) {
    // Build nametag with cycle count + progress — use character name
    let label = (AGENT_NAMES[agentData.id] || agentData.name || agentData.id).toUpperCase();
    let statsHtml = '';
    const parts = [];
    if (agentData.cycles > 0) parts.push(`${agentData.cycles} cycles`);
    const p = agentData.progress;
    if (p && p.total > 0) parts.push(`${p.current}/${p.total}`);
    if (parts.length) statsHtml = `<span class="tag-stats">${parts.join(' · ')}</span>`;
    tag.innerHTML = label + statsHtml;
  }
}

// ── Speech Bubble Typewriter ──
function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function updateSpeechBubble(agentId, text, bgColor) {
  const bubble = document.getElementById(`bubble-${agentId}`);
  if (!bubble) return;
  if (bubble.dataset.fullText === text) return;
  bubble.dataset.fullText = text;

  if (typewriterTimers[agentId]) {
    clearInterval(typewriterTimers[agentId]);
    typewriterTimers[agentId] = null;
  }

  // Apply agent-colored background or reset to default
  if (bgColor) {
    const tint = hexToRgba(bgColor, 0.18);
    bubble.style.background = tint;
    bubble.style.setProperty('--bubble-bg', tint);
  } else {
    bubble.style.background = '';
    bubble.style.setProperty('--bubble-bg', '#fff');
  }

  bubble.classList.add('visible');
  bubble.textContent = '';

  let i = 0;
  typewriterTimers[agentId] = setInterval(() => {
    if (i < text.length) {
      bubble.textContent = text.substring(0, i + 1);
      i++;
    } else {
      clearInterval(typewriterTimers[agentId]);
      typewriterTimers[agentId] = null;
      const displayTime = Math.max(8000, text.length * 80);
      setTimeout(() => {
        if (bubble.dataset.fullText === text) {
          bubble.classList.remove('visible');
          bubble.style.background = '';
          bubble.style.setProperty('--bubble-bg', '#fff');
        }
      }, displayTime);
    }
  }, 35);
}

// ── Agent Movement ──
function moveAgentTo(agentId, xPct, yPct, showFront = false) {
  const charEl = agentCharElements[agentId];
  const uiEl = agentUIElements[agentId];
  if (!charEl || !uiEl) return;

  if (showFront) {
    charEl.classList.add('show-front');
  } else {
    charEl.classList.remove('show-front');
  }

  charEl.style.left = xPct + '%';
  charEl.style.top = yPct + '%';
  uiEl.style.left = xPct + '%';
  uiEl.style.top = yPct + '%';
}

// ── Editor Aisle Pathfinding ──
// Routes the Editor along aisles — never diagonally through desks.
// Rule: to change rows, first go to center aisle (x=50), walk vertically, then walk to destination X.
const AISLE_X = 50;
const EDITOR_WALK_SPEED = 35; // percent-units per second

async function walkEditorTo(destX, destY, options = {}) {
  // options.finalSprite — sprite to show when done (e.g. 'front', 'back', 'clipboard')
  // options.carrySprite — sprite override during all walk segments (e.g. 'clipboard')
  const charEl = agentCharElements['editor'];
  const uiEl = agentUIElements['editor'];
  if (!charEl || !uiEl) return;

  const curX = parseFloat(charEl.style.left) || AGENT_CONFIG.editor.homeX;
  const curY = parseFloat(charEl.style.top) || AGENT_CONFIG.editor.homeY;

  // Build waypoints
  const waypoints = [];
  const isOnAisle = Math.abs(curX - AISLE_X) < 3;
  const destIsOnAisle = Math.abs(destX - AISLE_X) < 3;
  const sameRow = Math.abs(curY - destY) < 3;

  if (sameRow) {
    // Same row — walk horizontally
    waypoints.push({ x: destX, y: curY });
  } else {
    // Different row — route through center aisle
    if (!isOnAisle) {
      waypoints.push({ x: AISLE_X, y: curY }); // Step to aisle
    }
    waypoints.push({ x: AISLE_X, y: destY }); // Walk aisle vertically
    if (!destIsOnAisle) {
      waypoints.push({ x: destX, y: destY }); // Walk to final X
    }
  }

  // Walk each segment
  let prevX = curX, prevY = curY;
  for (const wp of waypoints) {
    const dx = wp.x - prevX;
    const dy = wp.y - prevY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) { prevX = wp.x; prevY = wp.y; continue; }

    const duration = Math.max(0.4, Math.min(2.0, dist / EDITOR_WALK_SPEED));

    // Set walk sprite
    if (options.carrySprite) {
      editorSetSprite(options.carrySprite);
    } else if (Math.abs(dy) >= Math.abs(dx)) {
      editorSetSprite(dy < 0 ? 'back' : 'front');
    }
    // For horizontal moves with no carrySprite, keep current sprite

    // Set transition speed proportional to distance
    const trans = `left ${duration}s ease-in-out, top ${duration}s ease-in-out`;
    charEl.style.transition = trans;
    uiEl.style.transition = trans;

    charEl.style.left = wp.x + '%';
    charEl.style.top = wp.y + '%';
    uiEl.style.left = wp.x + '%';
    uiEl.style.top = wp.y + '%';

    await sleep(duration * 1000 + 50);
    prevX = wp.x;
    prevY = wp.y;
  }

  // Reset to default CSS transition
  charEl.style.transition = '';
  uiEl.style.transition = '';

  if (options.finalSprite) editorSetSprite(options.finalSprite);
}

function moveAgentHome(agentId) {
  const cfg = AGENT_CONFIG[agentId];
  if (cfg) moveAgentTo(agentId, cfg.homeX, cfg.homeY, false);
}

// ── Collaboration System (Hub-and-Spoke: Editor mediates all exchanges) ──
// Queue ensures meetings execute sequentially without being dropped by editorBusy
const meetingQueue = [];
let processingQueue = false;

async function processMeetingQueue() {
  if (processingQueue) return;
  processingQueue = true;
  while (meetingQueue.length > 0) {
    // Wait for any direct editor behavior to finish
    while (editorBusy) await sleep(300);
    editorBusy = true;
    const { agentId, label, type } = meetingQueue.shift();
    await doCollabMeeting(agentId, label, type);
    editorBusy = false;
    await sleep(500);
  }
  processingQueue = false;
}

function triggerCollaboration(fromId, toId, label, type) {
  // In hub-and-spoke model, all collaborations route through Editor
  if (fromId !== 'editor' && toId !== 'editor') {
    meetingQueue.push({ agentId: fromId, label, type: type || 'handoff' });
    meetingQueue.push({ agentId: toId, label, type: type || 'handoff' });
    processMeetingQueue();
    return;
  }
  const agentId = fromId === 'editor' ? toId : fromId;
  const collabType = type || (fromId === 'editor' ? 'assign' : 'deliver');
  meetingQueue.push({ agentId, label, type: collabType });
  processMeetingQueue();
}

/**
 * Dispatches to the right animation based on collaboration type:
 *   'assign'  — Miranda picks up clipboard from board, walks to agent, delivers task
 *   'deliver' — Miranda walks to agent, collects result (happy), logs on completed board
 *   'handoff' — Simple walk-and-talk exchange
 * Called from the queue with editorBusy already set.
 */
async function doCollabMeeting(agentId, label, type) {
  const target = AGENT_CONFIG[agentId];
  if (!target) return;
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Yellow glow on both
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  if (type === 'assign') {
    // ── ASSIGN: Miranda grabs clipboard, walks to agent ──
    editorSetSprite('clipboard');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(600);
    await walkEditorTo(50, target.homeY, { carrySprite: 'clipboard' });
    editorSetSprite('front');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(2500);

    // Cleanup
    if (editorChar) editorChar.classList.remove('editor-engage');
    if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
    moveAgentHome(agentId);
    await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  } else if (type === 'deliver') {
    // ── DELIVER: Miranda walks to agent, collects result, logs on board ──
    await walkEditorTo(50, target.homeY);
    // Agent speaks their result first
    if (label) updateSpeechBubble(agentId, label);
    await sleep(1500);
    // Miranda reacts in character
    editorSetSprite('happy');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(2000);

    // Clear glow, agent returns while Miranda heads to completed board
    if (editorChar) editorChar.classList.remove('editor-engage');
    if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
    moveAgentHome(agentId);
    await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y, { carrySprite: 'clipboard' });
    editorSetSprite('clipboard');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(1500);
    await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  } else {
    // ── HANDOFF: Simple walk-and-talk ──
    const goingUp = target.homeY < cfg.homeY;
    editorSetSprite(goingUp ? 'back' : 'front');
    moveAgentTo('editor', 50, target.homeY, !goingUp);
    if (goingUp) editorSetSprite('back');
    await sleep(1800);
    editorSetSprite('front');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(2500);

    // Cleanup
    if (editorChar) editorChar.classList.remove('editor-engage');
    if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
    moveAgentHome(agentId);
    const goingHome = cfg.homeY > target.homeY;
    editorSetSprite(goingHome ? 'front' : 'back');
    moveAgentTo('editor', cfg.homeX, cfg.homeY, goingHome);
    if (!goingHome) editorSetSprite('back');
    await sleep(1800);
    editorSetSprite('front');
  }
}

function renderCollaborations(collaborations) {
  if (!collaborations || !collaborations.length) return;
  const newCollabs = collaborations.filter(c => {
    const key = `${c.from}-${c.to}-${c.label}`;
    if (activeCollaborations.includes(key)) return false;
    activeCollaborations.push(key);
    if (activeCollaborations.length > 20) activeCollaborations.shift();
    return true;
  });
  if (newCollabs.length > 0) {
    newCollabs.forEach((c) => {
      triggerCollaboration(c.from, c.to, c.label || '', c.type || 'handoff');
    });
  }
}

// ══════════════════════════════════════
// RENDERING — Top Bar
// ══════════════════════════════════════
function renderTitle(data) {
  document.getElementById('main-title').textContent = 'AGENT OFFICE';
  document.title = 'Agent Office';
}

function renderTopStats(stats) {
  const container = document.getElementById('top-stats');
  if (!stats || !stats.length) {
    container.innerHTML = '';
    return;
  }
  container.innerHTML = stats.map(s => {
    const display = s.total ? `${s.value}/${s.total}` : String(s.value);
    const hasDetails = s.details && s.details.length > 0;
    const cls = hasDetails ? 'top-stat has-details' : 'top-stat';
    const popupType = s.popup_type || 'confirmed';
    return `<div class="${cls}"
      ${hasDetails ? `data-details='${JSON.stringify(s.details).replace(/'/g, "&#39;")}'` : ''}
      ${hasDetails ? `data-popup-type="${popupType}"` : ''}>
      <span class="top-stat-value">${escHtml(display)}</span>
      <span class="top-stat-label">${escHtml(s.label)}</span>
    </div>`;
  }).join('');

  // Attach right-click handler to stats with details
  container.querySelectorAll('.has-details').forEach(el => {
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const details = JSON.parse(el.dataset.details);
      const popupType = el.dataset.popupType || 'confirmed';
      showStatPopup(e, details, popupType);
    });
  });
}

/** Show a popup with stat details near the cursor. Dispatches by popupType. */
function showStatPopup(event, details, popupType) {
  // Remove any existing popup
  const old = document.getElementById('stat-popup');
  if (old) old.remove();

  const popup = document.createElement('div');
  popup.id = 'stat-popup';
  popup.style.cssText = `
    position: fixed; z-index: 9999;
    left: ${event.clientX + 4}px;
    background: #1a0e2e; border: 2px solid var(--gold);
    padding: 12px 16px; min-width: 240px; max-width: 420px;
    max-height: 400px; overflow-y: auto;
    font-family: 'Press Start 2P', monospace;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  `;
  // Position above cursor if near bottom of viewport
  const spaceBelow = window.innerHeight - event.clientY;
  if (spaceBelow < 300) {
    popup.style.bottom = (window.innerHeight - event.clientY + 4) + 'px';
  } else {
    popup.style.top = (event.clientY + 4) + 'px';
  }

  let html = '';
  if (popupType === 'memories') {
    html = renderMemoriesPopup(details);
  } else if (popupType === 'dossiers') {
    html = renderDossiersPopup(details);
  } else {
    html = renderConfirmedPopup(details);
  }

  popup.innerHTML = html;
  document.body.appendChild(popup);

  // Close on any click
  const close = () => { popup.remove(); document.removeEventListener('click', close); };
  setTimeout(() => document.addEventListener('click', close), 100);
}

function renderConfirmedPopup(details) {
  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">CONFIRMED ASSOCIATES</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">None yet</div>';
  } else {
    for (const d of details) {
      const color = d.strength === 'high' ? '#e74c3c' : '#e67e22';
      html += `<div style="margin-bottom:8px; padding:6px 8px; border-left:3px solid ${color}; background:rgba(255,255,255,0.03);">
        <div style="font-size:9px; color:var(--text);">${escHtml(d.name)}</div>
        <div style="font-size:7px; color:${color}; margin-top:3px; text-transform:uppercase;">${escHtml(d.strength)} connection</div>
        <div style="font-size:7px; color:var(--text-dim); margin-top:3px; line-height:1.5;">${escHtml(d.rationale || '')}</div>
      </div>`;
    }
  }
  return html;
}

function renderMemoriesPopup(details) {
  const agentColors = {
    scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71',
    detective: '#9b59b6', researcher: '#e67e22', editor: '#f5c842', designer: '#e91e63',
  };
  const outcomeColors = { success: '#2ecc71', failure: '#e74c3c', decision: '#3498db', observation: '#888' };

  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">AGENT MEMORIES</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">No memories yet</div>';
  } else {
    for (const m of details) {
      const ac = agentColors[m.agent] || '#888';
      const oc = outcomeColors[m.outcome] || '#888';
      html += `<div style="margin-bottom:6px; padding:5px 7px; border-left:2px solid ${ac}; background:rgba(255,255,255,0.02);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:3px;">
          <span style="font-size:6px; color:${ac}; text-transform:uppercase;">${escHtml(m.agent)}</span>
          <span style="font-size:5px; color:var(--text-muted);">${escHtml(m.time)}</span>
        </div>
        <div style="font-size:7px; color:var(--text-dim); line-height:1.5;">${escHtml(m.text)}</div>
        <span style="font-size:5px; color:${oc}; text-transform:uppercase; letter-spacing:0.3px;">${escHtml(m.outcome)}</span>
      </div>`;
    }
  }
  return html;
}

function renderDossiersPopup(details) {
  const strengthColors = { high: '#e74c3c', medium: '#e67e22', low: '#f1c40f', coincidence: '#888', unknown: '#555' };

  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">ALL DOSSIERS</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">No dossiers yet</div>';
  } else {
    for (const d of details) {
      const sc = strengthColors[d.strength] || '#888';
      const verdictColor = d.editor_verdict === 'CONFIRMED' ? '#2ecc71'
        : d.editor_verdict === 'REJECTED' ? '#e74c3c' : '';
      html += `<div style="margin-bottom:8px; padding:6px 8px; border-left:3px solid ${sc}; background:rgba(255,255,255,0.03);">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <span style="font-size:9px; color:var(--text);">${escHtml(d.name)}</span>
          ${d.editor_verdict ? `<span style="font-size:6px; color:${verdictColor}; letter-spacing:0.5px;">${escHtml(d.editor_verdict)}</span>` : ''}
        </div>
        <div style="font-size:7px; color:${sc}; margin-top:3px; text-transform:uppercase;">${escHtml(d.strength)} connection</div>
        ${d.strength_rationale ? `<div style="font-size:6px; color:var(--text-dim); margin-top:3px; line-height:1.5;">${escHtml(d.strength_rationale)}</div>` : ''}
        ${d.editor_reasoning ? `<div style="font-size:6px; color:${verdictColor}; margin-top:3px; line-height:1.5; opacity:0.8;">${escHtml(d.editor_reasoning)}</div>` : ''}
      </div>`;
    }
  }
  return html;
}

// ══════════════════════════════════════
// RENDERING — Left Panel
// ══════════════════════════════════════
function renderPipeline(pipeline) {
  const container = document.getElementById('pipeline-content');
  if (!pipeline || !pipeline.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No data</div>';
    return;
  }
  const maxTotal = Math.max(...pipeline.map(p => p.total || p.count), 1);
  container.innerHTML = pipeline.map(p => {
    const total = p.total || p.count;
    const pct = Math.max(2, (p.count / maxTotal) * 100);
    const label = total > p.count ? `${p.count}/${total}` : `${p.count}`;
    return `<div class="pipeline-row">
      <span class="pipeline-label">${escHtml(p.stage)}</span>
      <div class="pipeline-bar-wrap">
        <div class="pipeline-bar" style="width:${pct}%;background:${p.color}"></div>
      </div>
      <span class="pipeline-count">${label}</span>
    </div>`;
  }).join('');
}

function renderQueueDepths(queues) {
  const container = document.getElementById('queues-content');
  if (!queues || !queues.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No queues</div>';
    return;
  }
  container.innerHTML = queues.map(q =>
    `<div class="queue-row">
      <div class="queue-dot" style="background:${q.color}"></div>
      <span class="queue-count">${q.count}</span>
      <span class="queue-label">${escHtml(q.label)}</span>
    </div>`
  ).join('');
}

function renderInbox(messages) {
  const container = document.getElementById('inbox-content');

  // Merge server messages with pending optimistic messages
  let allMessages = messages ? [...messages] : [];

  // Add any pending human messages not yet reflected in server data
  for (const pm of pendingHumanMessages) {
    const alreadyInServer = allMessages.some(m =>
      m.sender === 'human' && m.text === pm.text && m.time === pm.time
    );
    if (!alreadyInServer) {
      allMessages.push(pm);
    }
  }

  // Clean up pending messages that are now in server data
  pendingHumanMessages = pendingHumanMessages.filter(pm =>
    !allMessages.some(m => m !== pm && m.sender === 'human' && m.text === pm.text && m.time === pm.time)
  );

  // Sort by timestamp descending (newest first) so human + editor messages interleave correctly
  allMessages.sort((a, b) => {
    const ta = a.timestamp || a.time || '';
    const tb = b.timestamp || b.time || '';
    return tb.localeCompare(ta);
  });

  if (!allMessages.length) {
    container.innerHTML = '<div class="inbox-empty">No messages yet</div>';
    return;
  }
  container.innerHTML = allMessages.map(m => {
    const isHuman = m.sender === 'human';
    let cls = 'inbox-msg';
    if (isHuman) cls += ' human';
    else if (m.is_reply) cls += ' reply';
    else if (m.type === 'alert') cls += ' alert';
    const opacity = m.pending ? ' style="opacity:0.6"' : '';
    return `<div class="${cls}"${opacity}>
      <div class="inbox-msg-time">${escHtml(m.time || '')}</div>
      <div class="inbox-msg-text">${escHtml(m.text || '')}</div>
    </div>`;
  }).join('');

  // Auto-scroll to top (newest messages are first) unless user has scrolled down
  const scrollParent = container.closest('.inbox-scroll') || container;
  if (!scrollParent._userScrolled || scrollParent.scrollTop < 80) {
    scrollParent.scrollTop = 0;
  }
}

function toggleChatter() {
  document.getElementById('chatter-section').classList.toggle('collapsed');
}

// Agent color map for watercooler speaker coloring
const AGENT_COLORS = {
  scout: '#27ae60', courier: '#3498db', reader: '#9b59b6',
  detective: '#e67e22', researcher: '#e74c3c', editor: '#f5c842', designer: '#e91e63',
};

let activeWatercoolerConvo = null;  // Track currently displayed conversation
let watercoolerBubbleTimer = null;  // Timer for sequential bubble animation

function renderWatercooler(convo) {
  if (!convo || !convo.lines || !convo.lines.length) {
    // No active conversation — clear any previous watercooler display
    if (activeWatercoolerConvo) {
      activeWatercoolerConvo = null;
      if (watercoolerBubbleTimer) {
        clearTimeout(watercoolerBubbleTimer);
        watercoolerBubbleTimer = null;
      }
    }
    return '';
  }

  // Check if this is a new conversation (different from what we're showing)
  const convoKey = convo.timestamp;
  if (activeWatercoolerConvo === convoKey) return null; // Already displaying
  activeWatercoolerConvo = convoKey;

  // Build HTML for chatter panel
  const linesHtml = convo.lines.map(ln => {
    const color = AGENT_COLORS[ln.speaker_id] || 'var(--text)';
    const bgTint = AGENT_COLORS[ln.speaker_id] ? hexToRgba(AGENT_COLORS[ln.speaker_id], 0.12) : 'transparent';
    return `<div class="watercooler-line" style="background:${bgTint};border-radius:3px;padding:2px 4px;margin:1px 0">
      <span class="wc-speaker" style="color:${color}">${escHtml(ln.speaker)}:</span>
      <span class="chatter-text">${escHtml(ln.text)}</span>
    </div>`;
  }).join('');

  // Animate speech bubbles on sprites — show each line sequentially
  animateWatercoolerBubbles(convo);

  return `<div class="watercooler-convo">
    <div class="watercooler-header">watercooler</div>
    ${linesHtml}
  </div>`;
}

function animateWatercoolerBubbles(convo) {
  if (watercoolerBubbleTimer) {
    clearTimeout(watercoolerBubbleTimer);
    watercoolerBubbleTimer = null;
  }

  const lines = convo.lines || [];
  let lineIndex = 0;
  const DELAY_PER_LINE = 6000; // 6 seconds per line

  function showNextLine() {
    if (lineIndex >= lines.length) return;
    const line = lines[lineIndex];
    // Get the speaker's agent color for the bubble tint
    const speakerColor = AGENT_COLORS[line.speaker_id] || null;
    updateSpeechBubble(line.speaker_id, line.text, speakerColor);
    lineIndex++;
    if (lineIndex < lines.length) {
      watercoolerBubbleTimer = setTimeout(showNextLine, DELAY_PER_LINE);
    }
  }

  // Start after a brief pause
  watercoolerBubbleTimer = setTimeout(showNextLine, 500);
}

function renderChatter(notes, watercooler) {
  const container = document.getElementById('chatter-content');

  let html = '';

  // Show active watercooler conversation at the top
  if (watercooler) {
    const wcHtml = renderWatercooler(watercooler);
    if (wcHtml) html += wcHtml;
  }

  // Then bulletin board notes
  if (!notes || !notes.length) {
    if (!html) {
      container.innerHTML = '<div class="chatter-empty">Agents haven\'t posted yet...</div>';
      return;
    }
  } else {
    html += notes.map(n => {
      const tagHtml = n.tag && n.tag !== 'tip' && n.tag !== 'chatter'
        ? `<span class="chatter-tag ${escHtml(n.tag)}">${escHtml(n.tag)}</span>`
        : '';
      // Truncate long messages
      const text = (n.text || '').length > 120 ? n.text.substring(0, 117) + '...' : (n.text || '');
      return `<div class="chatter-note" data-agent="${escHtml(n.agent || '')}">
        <span class="chatter-agent">${escHtml(n.name || n.agent || '?')}:</span>
        <span class="chatter-text">${escHtml(text)}</span>${tagHtml}
      </div>`;
    }).join('');
  }

  container.innerHTML = html;
}

async function sendInboxMessage() {
  const input = document.getElementById('inbox-input');
  const text = input.value.trim();
  if (!text) return;

  const now = new Date();
  const timeStr = now.getHours().toString().padStart(2,'0') + ':' + now.getMinutes().toString().padStart(2,'0');

  // Add to pending messages (survives re-renders)
  const pendingMsg = {
    time: timeStr,
    timestamp: now.toISOString(),
    text: text,
    sender: 'human',
    pending: true,
  };
  pendingHumanMessages.unshift(pendingMsg);

  input.value = '';

  // Re-render inbox with the pending message
  renderInbox(currentState ? currentState.editor_inbox : []);

  try {
    await fetch('/api/inbox', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text }),
    });
    pendingMsg.pending = false;
  } catch (e) {
    console.error('Failed to send message:', e);
    pendingMsg.failed = true;
    showToast('MESSAGE FAILED — server offline?', 'error');
  }
}

function summarizeTask(task, agentId, isActive) {
  if (!task) return '';
  const t = task.toLowerCase();
  if (!isActive) {
    if (t.includes('waiting')) return 'Waiting';
    if (t.includes('offline')) return 'Offline';
    if (t.includes('all ')) return 'Done';
    if (t.includes('ready')) return 'Ready';
    return 'Idle';
  }
  if (t.includes('discover') || t.includes('found') || t.includes('index')) return 'Scouting';
  if (t.includes('download')) return 'Downloading';
  if (t.includes('extract') || t.includes('reading')) return 'Extracting';
  if (t.includes('check') || t.includes('cross-ref')) return 'Checking';
  if (t.includes('investigat') || t.includes('dossier')) return 'Investigating';
  if (t.includes('supervis') || t.includes('pipeline')) return 'Supervising';
  if (t.includes('train') || t.includes('study') || t.includes('pattern')) return 'Training';
  if (t.includes('scrape') || t.includes('scraping')) return 'Scraping';
  if (t.includes('lead')) return 'Investigating';
  return 'Working';
}

function renderNowProcessing(now) {
  const container = document.getElementById('now-content');
  if (!now || Object.keys(now).length === 0) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">Idle</div>';
    return;
  }

  const colors = { editor: '#f5c842', scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71', detective: '#9b59b6', researcher: '#e67e22', designer: '#e91e63' };
  const roles = { scout: 'Scout', courier: 'Courier', reader: 'Reader', editor: 'Editor', detective: 'Detective', researcher: 'Researcher', designer: 'Designer' };

  // Zigzag layout: top-left → center → right → center → left → right → center-bottom
  const positions = {
    scout:      { x: 18, y: 2 },
    courier:    { x: 50, y: 16 },
    reader:     { x: 82, y: 30 },
    editor:     { x: 50, y: 40 },
    detective:  { x: 18, y: 62 },
    researcher: { x: 82, y: 76 },
    designer:   { x: 50, y: 91 }
  };

  // Hub-and-spoke: Miranda (editor) connects to every agent
  const spokes = ['scout', 'courier', 'reader', 'detective', 'researcher', 'designer'];

  // Build SVG connection lines — all radiate from Miranda
  // A spoke lights up when its agent is active (Miranda is always the other end)
  const ep = positions.editor;
  let svgLines = '';
  for (const agent of spokes) {
    const ap = positions[agent];
    const agentActive = now[agent]?.active;
    // Spoke activates when the agent is working — Miranda is implicitly the other end
    const color = agentActive ? colors[agent] : 'rgba(255,255,255,0.06)';
    const cls = agentActive ? 'network-line active' : 'network-line';
    // Connect from editor box center toward agent box edge
    const ey = ep.y + 4;
    const ay = ap.y < ep.y ? ap.y + 6 : ap.y + 1;
    svgLines += `<line x1="${ep.x}" y1="${ey}" x2="${ap.x}" y2="${ay}" class="${cls}" style="stroke:${color}" />`;
  }

  // Miranda is active if she's working OR any worker agent is active
  const anyWorkerActive = spokes.some(a => now[a]?.active);
  const editorIsActive = now.editor?.active || anyWorkerActive;

  // Build agent nodes
  const order = ['scout', 'courier', 'reader', 'editor', 'detective', 'researcher', 'designer'];
  let nodes = '';
  for (const id of order) {
    const pos = positions[id];
    const info = now[id] || { task: 'Offline', active: false };
    const color = colors[id];
    const isActive = id === 'editor' ? editorIsActive : info.active;
    const isEditor = id === 'editor';
    const cls = `network-node ${isActive ? 'active' : 'idle'}${isEditor ? ' network-editor' : ''}`;
    const roleColor = isActive ? color : 'var(--text-dim)';

    const taskWord = summarizeTask(info.task, id, isActive);
    nodes += `<div class="${cls}" style="left:${pos.x}%;top:${pos.y}%;--agent-glow:${color}40">
      <div class="network-role" style="color:${roleColor}">${roles[id]}</div>
      <div class="network-name">${AGENT_NAMES[id] || id}</div>
      <div class="network-dot${isActive ? ' active' : ''}" style="background:${color}"></div>
      <div class="network-task">${escHtml(taskWord)}</div>
    </div>`;
  }

  container.innerHTML = `<div class="agent-network">
    <svg viewBox="0 0 100 100" preserveAspectRatio="none">
      ${svgLines}
    </svg>
    ${nodes}
  </div>`;
}

// ══════════════════════════════════════
// RENDERING — Right Panel
// ══════════════════════════════════════
let cachedLog = [];

function renderLogWithFilters(log) {
  cachedLog = log || [];
  renderLogFiltered();
}

// Map character names back to role names for log filtering
const CHAR_TO_ROLE = {};
const ROLE_TO_CHAR = {};
for (const [roleId, charName] of Object.entries(AGENT_NAMES)) {
  const roleName = roleId.charAt(0).toUpperCase() + roleId.slice(1);
  CHAR_TO_ROLE[charName] = roleName;
  ROLE_TO_CHAR[roleName] = charName;
}

function renderLogFiltered() {
  const container = document.getElementById('log-entries');
  // activeLogFilter uses character names — map to role names for log data matching
  const roleFilter = CHAR_TO_ROLE[activeLogFilter] || activeLogFilter;
  const filtered = activeLogFilter === 'All'
    ? cachedLog
    : cachedLog.filter(e => e.agent === roleFilter || e.agent === activeLogFilter);

  if (!filtered.length) {
    container.innerHTML = '<div class="log-entry"><span class="log-event">No activity yet...</span></div>';
    return;
  }
  const agentColors = { Editor: '#f5c842', Scout: '#e74c3c', Courier: '#3498db', Reader: '#2ecc71', Detective: '#9b59b6', Researcher: '#e67e22', Designer: '#e91e63' };
  container.innerHTML = filtered.map(entry => {
    const color = agentColors[entry.agent] || 'var(--gold)';
    return `<div class="log-entry">
      <span class="log-time">${escHtml(entry.time || '')}</span>
      <span class="log-agent" style="color:${color}">${escHtml(ROLE_TO_CHAR[entry.agent] || entry.agent || '')}</span>
      <span class="log-event">${escHtml(entry.event || '')}</span>
    </div>`;
  }).join('');
}

const _prevFinds = new Set();
function renderNotableFinds(finds) {
  const container = document.getElementById('finds-content');
  if (!finds || !finds.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No current leads yet</div>';
    return;
  }
  const currentKeys = new Set(finds.map(f => f.name));
  container.innerHTML = finds.map(f => {
    const typeClass = f.type || '';
    const isNew = !_prevFinds.has(f.name) && _prevFinds.size > 0;
    const meta = [f.issue, f.location].filter(Boolean).join(' \u00B7 ');

    // Build pipeline stages
    const pipeline = buildFindPipeline(f);

    return `<div class="find-card ${typeClass}${isNew ? ' new-find' : ''}">
      <div class="find-name">${escHtml(f.name)}</div>
      ${meta ? `<div class="find-meta">${escHtml(meta)}</div>` : ''}
      <div class="find-pipeline">${pipeline}</div>
    </div>`;
  }).join('');
  // Track for next render — detect new arrivals
  _prevFinds.clear();
  currentKeys.forEach(k => _prevFinds.add(k));
}

/** Build the DET → RES → EDT pipeline HTML for a notable find. */
function buildFindPipeline(f) {
  const status = f.status || '';
  const research = f.research || '';
  const researchDetail = f.research_detail || '';

  // ── DET stage ──
  const detColors = {
    confirmed_match: '#e74c3c',
    likely_match: '#e67e22',
    possible_match: '#f1c40f',
    needs_review: '#3498db',
    pending: '#666',
  };
  const detLabels = {
    confirmed_match: 'CONFIRMED',
    likely_match: 'LIKELY',
    possible_match: 'POSSIBLE',
    needs_review: 'REVIEW',
    pending: 'PENDING',
  };
  const detColor = detColors[status] || '#666';
  const detLabel = detLabels[status] || status.toUpperCase();
  const detComplete = status && status !== 'pending';
  const detDot = detComplete ? 'complete' : '';
  const detHtml = `<span class="pipe-stage" style="color:${detColor}">` +
    `<span class="pipe-stage-label">DET</span>` +
    `<span class="pipe-dot ${detDot}"></span>` +
    `<span class="pipe-verdict">${detLabel}</span>` +
    `</span>`;

  // ── RES stage ──
  const resStarted = research && research !== 'null';
  const resComplete = research === 'dossier_complete';
  const resActive = research === 'investigating';
  const resQueued = research === 'queued';
  let resColor = '#666';
  let resDotClass = '';
  let resLabel = '';
  if (resComplete) {
    const strengthColors = { high: '#e74c3c', medium: '#e67e22', low: '#f1c40f', coincidence: '#888' };
    resColor = strengthColors[researchDetail] || '#2ecc71';
    resDotClass = 'complete';
    resLabel = (researchDetail || 'done').toUpperCase();
  } else if (resActive) {
    resColor = '#e67e22';
    resDotClass = 'active';
    resLabel = 'ACTIVE';
  } else if (resQueued) {
    resColor = '#888';
    resDotClass = '';
    resLabel = 'QUEUED';
  }
  const arrowDet = detComplete ? '' : ' dim';
  const resHtml = `<span class="pipe-arrow${arrowDet}">\u2192</span>` +
    `<span class="pipe-stage" style="color:${resColor}">` +
    `<span class="pipe-stage-label">RES</span>` +
    `<span class="pipe-dot ${resDotClass}"></span>` +
    (resLabel ? `<span class="pipe-verdict">${resLabel}</span>` : '') +
    `</span>`;

  // ── EDT stage ── (only visible when dossier is complete)
  let edtHtml = '';
  if (resComplete) {
    const arrowRes = '';
    const edtReviewed = f.editor_verdict && f.editor_verdict !== '';
    const edtColor = edtReviewed ? '#2ecc71' : '#666';
    const edtDotClass = edtReviewed ? 'complete' : '';
    const edtLabel = edtReviewed ? f.editor_verdict : 'PENDING';
    edtHtml = `<span class="pipe-arrow${arrowRes}">\u2192</span>` +
      `<span class="pipe-stage" style="color:${edtColor}">` +
      `<span class="pipe-stage-label">EDT</span>` +
      `<span class="pipe-dot ${edtDotClass}"></span>` +
      `<span class="pipe-verdict">${edtLabel}</span>` +
      `</span>`;
  }

  return detHtml + resHtml + edtHtml;
}


// ══════════════════════════════════════
// RENDERING — Live Badge
// ══════════════════════════════════════
function updateLiveBadge(timestamp) {
  const badge = document.getElementById('live-badge');
  const label = document.getElementById('live-label');
  if (!badge || !label) return;

  if (!timestamp) {
    badge.className = 'live-badge offline';
    label.textContent = 'OFFLINE';
    dataSource = 'offline';
    return;
  }

  const dataTime = new Date(timestamp).getTime();
  const now = Date.now();
  const ageSeconds = (now - dataTime) / 1000;

  if (ageSeconds < 15) {
    badge.className = 'live-badge live';
    label.textContent = 'LIVE';
    dataSource = 'live';
  } else if (ageSeconds < 120) {
    badge.className = 'live-badge stale';
    label.textContent = `STALE (${Math.round(ageSeconds)}s)`;
    dataSource = 'live'; // Still from live source, just old
  } else {
    badge.className = 'live-badge offline';
    label.textContent = 'OFFLINE';
    dataSource = 'offline';
  }
}

// ══════════════════════════════════════
// RENDERING — Cost Panel (above door)
// ══════════════════════════════════════
function renderCostTracker(cost) {
  const el = document.getElementById('cost-panel-value');
  if (!el) return;
  const rawTotal = (cost && cost.total_cost) || 0;
  el.textContent = '$' + rawTotal.toFixed(2);
}

// ══════════════════════════════════════
// RENDERING — Chalkboard Task Board
// ══════════════════════════════════════
const AGENT_COLORS_CHALK = {
  scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71',
  detective: '#9b59b6', researcher: '#e67e22', designer: '#e91e63', editor: '#f5c842'
};

function renderChalkboards(taskBoard, editorLedger) {
  const resultsEl = document.getElementById('chalk-results');
  if (!resultsEl) return;

  // ── Right board: Completed + Failed (most recent first, interleaved) ──
  const completed = (taskBoard?.completed || []).map(t => ({ ...t, _status: 'completed' }));
  const failed = (taskBoard?.failed || []).map(t => ({ ...t, _status: 'failed' }));
  const results = [...completed, ...failed].slice(-12).reverse();

  if (results.length === 0) {
    resultsEl.innerHTML = '<div class="chalk-empty">No results yet</div>';
  } else {
    resultsEl.innerHTML = results.map(task => {
      const agentId = (task.agent || task.completed_by || task.failed_by || '?').toLowerCase();
      const agent = AGENT_NAMES[agentId] || agentId;
      const goal = task._status === 'failed'
        ? (task.error || task.goal || task.type || 'Failed')
        : (task.goal || task.type || 'Done');
      const cls = task._status;
      return `<div class="chalk-item ${cls}">
        <span class="chalk-agent">${escHtml(agent)}</span>
        <span class="chalk-goal">${escHtml(goal)}</span>
      </div>`;
    }).join('');
  }
}

// ══════════════════════════════════════
// DISCOVERY COVERAGE MAP
// ══════════════════════════════════════
const MONTH_LABELS = ['J','F','M','A','M','J','J','A','S','O','N','D'];

let coverageMapBuilt = false;

function renderCoverageMap(coverageMap) {
  const el = document.getElementById('coverage-content');
  if (!el || !coverageMap) return;

  // Incremental update: if grid already built, only update changed cells
  if (coverageMapBuilt && previousState && previousState.coverage_map) {
    const prev = previousState.coverage_map;
    for (let y = 1988; y <= 2025; y++) {
      const yk = String(y);
      const yearData = coverageMap[yk] || {};
      const prevYear = prev[yk] || {};
      for (let m = 1; m <= 12; m++) {
        const mk = String(m);
        const newStatus = yearData[mk] || '';
        const oldStatus = prevYear[mk] || '';
        if (newStatus !== oldStatus) {
          const cell = el.querySelector(`[data-y="${y}"][data-m="${m}"]`);
          if (cell) {
            cell.className = `coverage-cell ${newStatus}`;
            cell.title = `${MONTH_LABELS[m-1]} ${y}: ${newStatus || 'missing'}`;
          }
        }
      }
    }
    return;
  }

  // First render: build full grid with data attributes
  let html = '<div class="coverage-grid">';

  html += '<div></div>';
  for (let m = 0; m < 12; m++) {
    html += `<div class="coverage-month-header">${MONTH_LABELS[m]}</div>`;
  }

  for (let y = 1988; y <= 2025; y++) {
    const showLabel = (y % 5 === 0 || y === 1988 || y === 2025);
    html += `<div class="coverage-year-label">${showLabel ? y : ''}</div>`;
    const yearData = coverageMap[String(y)] || {};
    for (let m = 1; m <= 12; m++) {
      const status = yearData[String(m)] || '';
      const title = `${MONTH_LABELS[m-1]} ${y}: ${status || 'missing'}`;
      html += `<div class="coverage-cell ${status}" data-y="${y}" data-m="${m}" title="${title}"></div>`;
    }
  }

  html += '</div>';

  html += `<div class="coverage-legend">
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:#e74c3c;opacity:0.6"></span>Unscouted</div>
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:#f1c40f;opacity:0.7"></span>Scouted</div>
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:#2ecc71;opacity:0.9"></span>Complete</div>
  </div>`;

  el.innerHTML = html;
  coverageMapBuilt = true;
}

// ══════════════════════════════════════
// AGENT CONTROLS — Floating Popup
// ══════════════════════════════════════
let activeControlAgent = null;

const AGENT_SUMMARIES = {
  editor:     'Pipeline supervisor. Assigns tasks, reviews output, commits to Supabase.',
  scout:      'Discovery specialist. Finds AD issues on archive.org and the AD Archive.',
  courier:    'Download agent. Retrieves PDFs and delivers them for extraction.',
  reader:     'Extraction specialist. Reads magazines and pulls homeowner data.',
  detective:  'Cross-reference agent. Checks names against Epstein records.',
  researcher: 'Investigation lead. Builds dossiers on confirmed matches.',
  designer:   'Frontend designer. Studies patterns and builds the Phase 3 website.',
};

function showAgentControlsPopup(agentId, clientX, clientY) {
  const popup = document.getElementById('agent-controls-popup');
  activeControlAgent = agentId;

  // Position at cursor — show above if near bottom of viewport
  popup.style.left = clientX + 'px';
  popup.style.top = '';
  popup.style.bottom = '';
  const spaceBelow = window.innerHeight - clientY;
  if (spaceBelow < 200) {
    popup.style.bottom = (window.innerHeight - clientY + 4) + 'px';
  } else {
    popup.style.top = clientY + 'px';
  }

  // Set button colors to match the agent
  const cfg = AGENT_CONFIG[agentId];
  if (cfg) popup.style.setProperty('--agent-color', cfg.color);

  // Populate header
  const name = AGENT_NAMES[agentId] || agentId;
  document.getElementById('ctrl-name').textContent = name.toUpperCase();
  document.getElementById('ctrl-desc').textContent = AGENT_SUMMARIES[agentId] || '';

  popup.classList.add('visible');

  // Show pause or resume based on current agent state
  const agentData = currentState?.agents?.find(a => a.id === agentId);
  const isPaused = agentData?.paused;
  document.getElementById('ctrl-pause').style.display = isPaused ? 'none' : '';
  document.getElementById('ctrl-resume').style.display = isPaused ? '' : 'none';
}

function hideAgentControlsPopup() {
  document.getElementById('agent-controls-popup').classList.remove('visible');
  activeControlAgent = null;
}

function initAgentControlsPopup() {
  document.getElementById('ctrl-pause').addEventListener('click', () => handleAgentControl('pause'));
  document.getElementById('ctrl-resume').addEventListener('click', () => handleAgentControl('resume'));
  document.getElementById('ctrl-skills').addEventListener('click', () => handleAgentControl('skills'));
  // Click anywhere else to dismiss
  document.addEventListener('click', (e) => {
    const popup = document.getElementById('agent-controls-popup');
    if (popup.classList.contains('visible') && !popup.contains(e.target)) {
      hideAgentControlsPopup();
    }
  });
}

async function handleAgentControl(command) {
  const agentId = activeControlAgent;
  if (!agentId) return;
  hideAgentControlsPopup();

  if (command === 'skills') {
    openSkillsModal(agentId);
    return;
  }

  try {
    const resp = await fetch(`/api/agent/${agentId}/${command}`, { method: 'POST' });
    if (resp.ok) {
      updateSpeechBubble(agentId, command === 'pause' ? 'Pausing...' : 'Resuming...');
      showToast(`${agentId.toUpperCase()} ${command.toUpperCase()}D`, 'success');
    } else {
      showToast(`${command.toUpperCase()} FAILED (${resp.status})`, 'error');
    }
  } catch (e) {
    console.error(`Failed to ${command} ${agentId}:`, e);
    showToast(`${command.toUpperCase()} FAILED — server offline?`, 'error');
  }
}

// ══════════════════════════════════════
// SKILLS MODAL
// ══════════════════════════════════════
let skillsCurrentAgent = null;
let skillsEditMode = false;

function initSkillsModal() {
  document.getElementById('skills-modal-close').addEventListener('click', () => {
    exitSkillsEditMode();
    document.getElementById('skills-modal').classList.remove('visible');
  });
  document.getElementById('skills-modal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) {
      exitSkillsEditMode();
      e.currentTarget.classList.remove('visible');
    }
  });

  // EDIT button — switch to edit mode
  document.getElementById('skills-edit-btn').addEventListener('click', () => {
    const content = document.getElementById('skills-content');
    const editor = document.getElementById('skills-editor');
    editor.value = content.textContent;
    content.style.display = 'none';
    editor.style.display = 'block';
    document.getElementById('skills-edit-btn').style.display = 'none';
    document.getElementById('skills-save-btn').style.display = '';
    document.getElementById('skills-cancel-btn').style.display = '';
    skillsEditMode = true;
    editor.focus();
  });

  // CANCEL button — discard changes, back to read mode
  document.getElementById('skills-cancel-btn').addEventListener('click', () => {
    exitSkillsEditMode();
  });

  // SAVE button — POST to API, then back to read mode
  document.getElementById('skills-save-btn').addEventListener('click', async () => {
    if (!skillsCurrentAgent) return;
    const editor = document.getElementById('skills-editor');
    const status = document.getElementById('skills-save-status');
    const saveBtn = document.getElementById('skills-save-btn');

    saveBtn.textContent = '...';
    saveBtn.style.pointerEvents = 'none';

    try {
      const resp = await fetch(`/api/skills/${skillsCurrentAgent}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: editor.value }),
      });
      if (!resp.ok) throw new Error(`Save failed (${resp.status})`);

      // Update the read-mode content with saved text
      document.getElementById('skills-content').textContent = editor.value;
      exitSkillsEditMode();

      status.textContent = 'SAVED';
      status.style.color = '#27ae60';
      status.style.display = '';
      showToast(`${skillsCurrentAgent.toUpperCase()} SKILLS SAVED`, 'success');
      setTimeout(() => { status.style.display = 'none'; }, 2000);
    } catch (e) {
      status.textContent = `ERROR: ${e.message}`;
      status.style.color = '#e74c3c';
      status.style.display = '';
      showToast(`SAVE FAILED — ${e.message}`, 'error');
      setTimeout(() => { status.style.display = 'none'; }, 3000);
    } finally {
      saveBtn.textContent = 'SAVE';
      saveBtn.style.pointerEvents = '';
    }
  });
}

function exitSkillsEditMode() {
  if (!skillsEditMode) return;
  document.getElementById('skills-content').style.display = '';
  document.getElementById('skills-editor').style.display = 'none';
  document.getElementById('skills-edit-btn').style.display = '';
  document.getElementById('skills-save-btn').style.display = 'none';
  document.getElementById('skills-cancel-btn').style.display = 'none';
  skillsEditMode = false;
}

async function openSkillsModal(agentId) {
  const modal = document.getElementById('skills-modal');
  const tabs = document.getElementById('skills-tabs');
  const content = document.getElementById('skills-content');

  modal.classList.add('visible');
  content.textContent = 'Loading skills...';

  // Fetch available skills
  try {
    const resp = await fetch('/api/skills');
    if (!resp.ok) throw new Error('API not available');
    const data = await resp.json();

    tabs.innerHTML = data.skills.map(s => {
      const active = s.agent === agentId ? ' active' : '';
      return `<button class="modal-tab${active}" data-agent="${s.agent}">${(AGENT_NAMES[s.agent] || s.agent).toUpperCase()}</button>`;
    }).join('');

    tabs.querySelectorAll('.modal-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        loadSkillContent(tab.dataset.agent);
      });
    });

    await loadSkillContent(agentId);
  } catch (e) {
    // Fallback if API is not available
    tabs.innerHTML = '';
    content.textContent = 'Skills API not available. Start the dashboard server:\npython3 src/dashboard_server.py';
  }
}

async function loadSkillContent(agentId) {
  exitSkillsEditMode();
  skillsCurrentAgent = agentId;
  const content = document.getElementById('skills-content');
  try {
    const resp = await fetch(`/api/skills/${agentId}`);
    if (!resp.ok) throw new Error('Not found');
    const data = await resp.json();
    content.textContent = data.content || '(empty)';
  } catch (e) {
    content.textContent = `Failed to load skills for ${agentId}`;
  }
}

// ══════════════════════════════════════
// RENDERING — Agents & Collaborations
// ══════════════════════════════════════
function renderAgents(agents) {
  if (!agents || !agents.length) return;
  agents.forEach(a => updateAgent(a));
}

function escHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function sectionChanged(key, data) {
  if (!previousState) return true;
  return JSON.stringify(data[key]) !== JSON.stringify(previousState[key]);
}

function renderAll(data) {
  const safe = (fn, label) => { try { fn(); } catch(e) { console.error(`renderAll: ${label} failed:`, e); } };
  // Always render: title, live badge, agents (already incremental)
  safe(() => renderTitle(data), 'title');
  safe(() => updateLiveBadge(data.timestamp), 'liveBadge');
  safe(() => renderAgents(data.agents), 'agents');
  // Diff-gated sections — skip render if data unchanged
  if (sectionChanged('stats', data))           safe(() => renderTopStats(data.stats), 'topStats');
  if (sectionChanged('now_processing', data))  safe(() => renderNowProcessing(data.now_processing), 'nowProcessing');
  if (sectionChanged('editor_inbox', data))    safe(() => renderInbox(data.editor_inbox), 'inbox');
  if (sectionChanged('bulletin', data) || sectionChanged('watercooler', data))
    safe(() => renderChatter(data.bulletin, data.watercooler), 'chatter');
  if (sectionChanged('log', data))             safe(() => renderLogWithFilters(data.log), 'log');
  if (sectionChanged('notable_finds', data))   safe(() => renderNotableFinds(data.notable_finds), 'notableFinds');
  if (sectionChanged('cost', data))             safe(() => renderCostTracker(data.cost), 'costTracker');
  if (sectionChanged('collaborations', data))   safe(() => renderCollaborations(data.collaborations), 'collaborations');
  if (sectionChanged('editor_ledger', data))    safe(() => renderChalkboards(data.task_board, data.editor_ledger), 'chalkboards');
  if (sectionChanged('coverage_map', data))     safe(() => renderCoverageMap(data.coverage_map), 'coverageMap');
  previousState = data;
}

// ══════════════════════════════════════
// KNOWLEDGE GRAPH
// ══════════════════════════════════════

// Colors synced with web/src/lib/graph-types.ts
const GRAPH_NODE_COLORS = {
  person: '#4A8FE7', designer: '#5CB3CC', location: '#E07A5F',
  style: '#6BAF7B', issue: '#C4A882', author: '#8B7D6B',
  epstein_source: '#E05A47',
};
const GRAPH_LINK_COLORS = {
  FEATURED_IN: '#C27C4E', HIRED: '#5CB3CC', LIVES_IN: '#E07A5F',
  HAS_STYLE: '#6BAF7B', PROFILED_BY: '#8B7D6B', APPEARS_IN: '#E05A47',
};
const GRAPH_EPSTEIN_COLOR = '#E05A47';
const GRAPH_UNCERTAINTY_COLOR = '#D4A04A';
const GRAPH_LABEL_DEGREE_THRESHOLD = 2;
const GRAPH_UNCERTAINTY_CONFIG = {
  high:     { blur: 2,  fillOpacity: 0.85, ringOpacity: 1.0, ringWidth: 2.0 },
  good:     { blur: 6,  fillOpacity: 0.6,  ringOpacity: 0.9, ringWidth: 1.8 },
  medium:   { blur: 12, fillOpacity: 0.35, ringOpacity: 0.8, ringWidth: 1.5 },
  low:      { blur: 18, fillOpacity: 0.15, ringOpacity: 0.7, ringWidth: 1.2 },
  very_low: { blur: 24, fillOpacity: 0.05, ringOpacity: 0.6, ringWidth: 1.0 },
};

function getNodeConfidence(node) {
  if (node.nodeType !== 'person') return null;
  if (node.editorVerdict === 'CONFIRMED') return 'high';
  if (node.editorVerdict === 'REJECTED') return null;
  if (node.detectiveVerdict === 'YES') {
    switch (node.connectionStrength) {
      case 'confirmed_match': return 'high';
      case 'likely_match': return 'good';
      case 'possible_match': return 'medium';
      case 'needs_review': return 'low';
      default: return 'medium';
    }
  }
  return null;
}

function graphNodeSize(degree, pagerank) {
  if (pagerank != null && pagerank > 0) {
    return Math.max(2, Math.min(8, 2 + pagerank * 400));
  }
  return Math.max(2, Math.min(7, 2 + degree * 0.35));
}

function initKnowledgeGraph() {
  // Collapsible toggle
  const toggle = document.getElementById('graph-panel-toggle');
  const body = document.getElementById('graph-panel-body');
  toggle.addEventListener('click', () => {
    graphCollapsed = !graphCollapsed;
    toggle.classList.toggle('collapsed', graphCollapsed);
    body.style.display = graphCollapsed ? 'none' : '';
    // Re-fit graph when expanding
    if (!graphCollapsed && graphInstance) {
      setTimeout(() => {
        const container = document.getElementById('graph-container');
        graphInstance.width(container.clientWidth).height(container.clientHeight);
      }, 50);
    }
  });

  // Initial fetch
  fetchGraphData();
}

function createGraphInstance() {
  const container = document.getElementById('graph-container');
  container.innerHTML = ''; // Remove placeholder

  let hoveredNodeId = null;

  graphInstance = ForceGraph()(container)
    .width(container.clientWidth)
    .height(container.clientHeight)
    .backgroundColor('#1a0e2e')
    .nodeCanvasObject((node, ctx, globalScale) => {
      const x = node.x || 0, y = node.y || 0;
      const color = GRAPH_NODE_COLORS[node.nodeType] || '#888';
      const degree = node._degree || 0;
      const size = graphNodeSize(degree, node.pagerank);
      const confidence = getNodeConfidence(node);
      const isHovered = hoveredNodeId === node.id;

      ctx.save();

      // Uncertainty ring (confidence-based glow)
      if (confidence) {
        const uc = GRAPH_UNCERTAINTY_CONFIG[confidence];
        ctx.save();
        ctx.shadowColor = GRAPH_UNCERTAINTY_COLOR;
        ctx.shadowBlur = uc.blur;
        ctx.beginPath();
        ctx.arc(x, y, size + 4, 0, 2 * Math.PI);
        ctx.strokeStyle = GRAPH_UNCERTAINTY_COLOR;
        ctx.lineWidth = uc.ringWidth / globalScale;
        ctx.globalAlpha = uc.ringOpacity;
        ctx.stroke();
        if (uc.fillOpacity > 0.05) {
          ctx.beginPath();
          ctx.arc(x, y, size + 3, 0, 2 * Math.PI);
          ctx.fillStyle = GRAPH_UNCERTAINTY_COLOR;
          ctx.globalAlpha = uc.fillOpacity * 0.3;
          ctx.fill();
        }
        ctx.restore();
      }

      // Hover ring
      if (isHovered) {
        ctx.beginPath();
        ctx.arc(x, y, size + 5, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1.5 / globalScale;
        ctx.stroke();
      }

      // Node body — outer ring + inner fill
      ctx.shadowColor = color;
      ctx.shadowBlur = isHovered ? 10 : 4;

      ctx.beginPath();
      ctx.arc(x, y, size, 0, 2 * Math.PI);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5 / globalScale;
      ctx.globalAlpha = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x, y, size * 0.55, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.globalAlpha = isHovered ? 0.9 : 0.7;
      ctx.fill();

      ctx.restore();

      // Labels — hide when zoomed out, show progressively as user zooms in
      const zoomedEnough = globalScale > 1.2;
      const zoomedClose  = globalScale > 2.5;
      const showLabel = isHovered || (zoomedClose && degree >= GRAPH_LABEL_DEGREE_THRESHOLD) || (zoomedEnough && degree >= GRAPH_LABEL_DEGREE_THRESHOLD * 2);
      if (showLabel && node.nodeType !== 'issue') {
        const labelAlpha = isHovered ? 1 : Math.min((globalScale - 1.2) / 1.5, 1);
        const fontSize = Math.max(10 / globalScale, 1.8);
        ctx.font = `${fontSize}px Inter, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        // Text shadow
        ctx.fillStyle = `rgba(0,0,0,${0.85 * labelAlpha})`;
        ctx.fillText(node.label, x + 0.5, y + size + 3 + 0.5);
        ctx.fillStyle = isHovered ? 'rgba(255,255,255,0.95)' : `rgba(255,255,255,${0.6 * labelAlpha})`;
        ctx.fillText(node.label, x, y + size + 3);
      }
    })
    .nodePointerAreaPaint((node, color, ctx) => {
      const size = graphNodeSize(node._degree || 0, node.pagerank);
      ctx.beginPath();
      ctx.arc(node.x || 0, node.y || 0, size + 8, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    })
    .onNodeHover(node => { hoveredNodeId = node ? node.id : null; })
    .linkColor(link => {
      const base = GRAPH_LINK_COLORS[link.relType] || '#444';
      return base + 'AA';
    })
    .linkWidth(link => {
      if (link.relType === 'APPEARS_IN') return 4;
      if (link.relType === 'HIRED') return 3;
      return 2.5;
    })
    .linkCurvature(0.2)
    .linkDirectionalParticles(2)
    .linkDirectionalParticleWidth(1.5)
    .linkDirectionalParticleSpeed(0.004)
    .d3AlphaDecay(0.02)
    .d3VelocityDecay(0.3)
    .cooldownTime(3000)
    .warmupTicks(30)
    .onNodeClick((node) => {
      showToast(`${node.label} (${node.nodeType})`, 'info', 2000);
    });
}

async function fetchGraphData() {
  if (graphCollapsed) return;
  try {
    const resp = await fetch('graph.json?t=' + Date.now());
    if (!resp.ok) return;
    const text = await resp.text();
    // Change detection — skip re-render if data unchanged
    if (text === lastGraphJSON) return;
    lastGraphJSON = text;
    const data = JSON.parse(text);
    renderGraph(data);
  } catch (e) {
    // Silently ignore — graph.json may not exist yet
  }
}

function renderGraph(data) {
  if (!data || !data.nodes || data.nodes.length === 0) return;

  // Compute degree per node
  const degreeMap = {};
  (data.links || []).forEach(l => {
    const src = typeof l.source === 'object' ? l.source.id : l.source;
    const tgt = typeof l.target === 'object' ? l.target.id : l.target;
    degreeMap[src] = (degreeMap[src] || 0) + 1;
    degreeMap[tgt] = (degreeMap[tgt] || 0) + 1;
  });
  data.nodes.forEach(n => { n._degree = degreeMap[n.id] || 0; });

  // Count communities
  const communities = new Set(data.nodes.map(n => n.communityId).filter(c => c != null));

  // Update stats bar
  document.getElementById('graph-stat-nodes').textContent = `${data.nodes.length} nodes`;
  document.getElementById('graph-stat-edges').textContent = `${data.links.length} edges`;
  document.getElementById('graph-stat-communities').textContent = `${communities.size} communities`;

  // Create instance if first render
  if (!graphInstance) {
    createGraphInstance();
  }

  graphInstance.graphData(data);
}

// ══════════════════════════════════════
// DEMO DATA
// ══════════════════════════════════════
const DEMO_DATA = {
  title: "AD-EPSTEIN INDEX \u2014 AGENT OFFICE",
  subtitle: "Architectural Digest research pipeline",
  timestamp: new Date().toISOString(),
  agents: [
    { id: "editor", name: "Miranda", status: "working", message: "Pipeline: GOOD — All systems operational", editor_state: "idle", errors: 0, paused: false },
    { id: "designer", name: "Sable", status: "idle", message: "Training mode — studying design patterns", errors: 0, paused: false },
    { id: "scout", name: "Arthur", status: "working", message: "Found 163 of 444 issues", errors: 0, paused: false },
    { id: "courier", name: "Casey", status: "working", message: "Downloading issue 31 of 163...", errors: 0, paused: false },
    { id: "reader", name: "Elias", status: "working", message: "Extracting features from Nov 2013", errors: 0, paused: false },
    { id: "detective", name: "Silas", status: "idle", message: "1 match found so far", errors: 0, paused: false },
    { id: "researcher", name: "Elena", status: "working", message: "Investigating Miranda Brooks...", errors: 0, paused: false }
  ],
  stats: [
    { label: "Discovered", value: 163, total: 444 },
    { label: "Downloaded", value: 75 },
    { label: "Extracted", value: 12 },
    { label: "Features", value: 89 },
    { label: "Matches", value: 1 },
    { label: "Dossiers", value: 3, popup_type: "dossiers", details: [
      { name: "Miranda Brooks", strength: "high", strength_rationale: "Direct match in Black Book...", editor_verdict: null, editor_reasoning: null },
      { name: "Isabel Goldsmith", strength: "low", strength_rationale: "Coincidental name overlap", editor_verdict: "REJECTED", editor_reasoning: "False positive" },
      { name: "Ghislaine Maxwell", strength: "high", strength_rationale: "Named associate", editor_verdict: "CONFIRMED", editor_reasoning: "Known associate" },
    ]},
    { label: "Confirmed", value: 1, popup_type: "confirmed", details: [
      { name: "Ghislaine Maxwell", strength: "high", rationale: "Named associate" },
    ]},
    { label: "Memories", value: 42, popup_type: "memories", details: [
      { agent: "scout", text: "Discovered AD Jan 2005 on archive.org via title search", outcome: "success", time: "10:32 PM" },
      { agent: "courier", text: "Downloaded architecturaldigest200501 (2005-01) from archive.org", outcome: "success", time: "10:30 PM" },
      { agent: "detective", text: "Cross-referenced Miranda Brooks against Black Book — exact match", outcome: "decision", time: "10:28 PM" },
    ]}
  ],
  now_processing: {
    editor: { task: "Pipeline GOOD — all agents active", active: true },
    scout: { task: "Found 163/444 (281 remaining)", active: true },
    courier: { task: "Downloading AD Mar 2005", active: true },
    reader: { task: "Extracting Nov 2013", active: true },
    detective: { task: "Checking Miranda Brooks", active: true },
    researcher: { task: "Building dossier — Miranda Brooks", active: true },
    designer: { task: "Training mode — studying design", active: false },
  },
  editor_inbox: [
    { time: "14:32", type: "status", text: "Pipeline health: GOOD. All 4 worker agents active. Courier at 46% download completion." },
    { time: "14:15", type: "alert", text: "First Epstein match found! Miranda Brooks appears in both AD Nov 2013 and the Black Book." },
    { time: "13:45", type: "status", text: "Reader extracted 8 features from Nov 2013. Quality looks strong — 77% name coverage." },
    { time: "13:00", type: "status", text: "Pipeline initialized. Scout found 163 of 444 expected issues on archive.org." },
  ],
  notable_finds: [
    { name: "Miranda Brooks", issue: "AD Nov 2013", location: "Connecticut", type: "epstein_match", status: "likely_match", research: "dossier_complete", research_detail: "high", editor_verdict: null },
    { name: "Isabel Goldsmith", issue: "AD Sep 2003", location: "Mexico City", type: "epstein_match", status: "possible_match", research: "investigating", research_detail: null, editor_verdict: null },
    { name: "Ghislaine Maxwell", issue: "AD Jan 2001", location: "New York", type: "epstein_match", status: "confirmed_match", research: "queued", research_detail: null, editor_verdict: null },
  ],
  quality: {
    total_features: 89,
    fields: [
      { label: "Names", filled: 69, total: 89, pct: 77 },
      { label: "Location", filled: 61, total: 89, pct: 69 },
      { label: "Designer", filled: 69, total: 89, pct: 77 },
      { label: "Year Built", filled: 34, total: 89, pct: 38 },
      { label: "Style", filled: 28, total: 89, pct: 31 },
      { label: "Sq Footage", filled: 22, total: 89, pct: 25 }
    ]
  },
  collaborations: [
    { from: "editor", to: "reader", type: "assign", label: "Extract features from AD Jan 2015" },
    { from: "scout", to: "editor", type: "deliver", label: "Done: Discovered 12 new issues" }
  ],
  log: [
    { time: "14:32", agent: "Courier", event: "Downloading AD March 2005..." },
    { time: "14:30", agent: "Reader", event: "Extracted 8 features from November 2013" },
    { time: "14:28", agent: "Detective", event: "Match found: Miranda Brooks (Black Book)" },
    { time: "14:25", agent: "Reader", event: "Extracted 6 features from October 2013" },
    { time: "14:20", agent: "Courier", event: "Downloaded AD issue #31" },
    { time: "14:15", agent: "Scout", event: "Discovery complete \u2014 163 issues indexed" },
    { time: "14:10", agent: "Courier", event: "Downloaded AD issue #30" },
    { time: "14:05", agent: "Reader", event: "Found George Clooney in Nov 2013" },
    { time: "14:00", agent: "Detective", event: "Checked 45 names, 1 match so far" }
  ],
  throughput: {
    downloads_per_hour: 4.5,
    extractions_per_hour: 1.2,
    eta_hours: 19.6,
  },
  cost: {
    api_calls: 47,
    input_tokens: 142000,
    output_tokens: 18500,
    total_cost: 0.1876,
  },
  task_board: {
    in_flight: [
      { id: 't1', agent: 'scout', type: 'discover_issues', goal: 'Find AD issues Jan-Mar 2015' },
      { id: 't2', agent: 'courier', type: 'download_pdf', goal: 'Download sim_ad_2005-03' },
      { id: 't3', agent: 'reader', type: 'extract_features', goal: 'Extract features from Nov 2013' },
      { id: 't4', agent: 'detective', type: 'cross_reference', goal: 'Check Miranda Brooks, Henri Samuel' },
    ],
    completed: [
      { id: 't5', agent: 'courier', type: 'download_pdf', goal: 'Downloaded sim_ad_2004-10' },
      { id: 't6', agent: 'reader', type: 'extract_features', goal: 'Extracted 8 features from Oct 2013' },
      { id: 't7', agent: 'scout', type: 'discover_issues', goal: 'Found 12 new issues on archive.org' },
    ],
    failed: [
      { id: 't8', agent: 'courier', type: 'download_pdf', goal: 'Download sim_ad_1995-03', error: '404 not found on archive.org' },
    ],
  },
  editor_ledger: {
    stuck: [
      { key: '2001-07', failures: 2, last_error: 'PDF corrupted, retry pending', agent: 'reader', task: 'extract_features' },
      { key: 'sim_ad_1999-11', failures: 1, last_error: 'Timeout on archive.org', agent: 'courier', task: 'download_pdf' },
    ],
    exhausted: [
      { key: 'sim_ad_1995-03', failures: 3, last_error: '404 not found on archive.org', agent: 'courier', task: 'download_pdf' },
      { key: '1992-05', failures: 3, last_error: 'No issue found for this month', agent: 'scout', task: 'discover_issues' },
    ],
    recent_failures: [
      { key: '2001-07', agent: 'reader', error: 'PDF corrupted, retry pending', time: '2026-02-09T14:30:00' },
      { key: 'sim_ad_1995-03', agent: 'courier', error: '404 not found', time: '2026-02-09T14:25:00' },
      { key: 'sim_ad_1999-11', agent: 'courier', error: 'Timeout on archive.org', time: '2026-02-09T14:20:00' },
      { key: '1992-05', agent: 'scout', error: 'No issue found', time: '2026-02-09T14:15:00' },
    ],
    total_keys: 18,
    total_failures: 9,
    total_successes: 34,
  },
  coverage_map: (() => {
    // Generate sample coverage map for demo
    const map = {};
    for (let y = 1988; y <= 2025; y++) {
      map[String(y)] = {};
      for (let m = 1; m <= 12; m++) {
        if (y < 1993) {
          // Early years: sparse discovery
          map[String(y)][String(m)] = Math.random() < 0.3 ? 'discovered' : null;
        } else if (y < 2000) {
          // Mid years: more discovered, some downloaded
          const r = Math.random();
          map[String(y)][String(m)] = r < 0.15 ? null : r < 0.4 ? 'discovered' : r < 0.7 ? 'downloaded' : 'extracted';
        } else if (y < 2015) {
          // 2000s: well covered
          const r = Math.random();
          map[String(y)][String(m)] = r < 0.05 ? null : r < 0.2 ? 'discovered' : r < 0.5 ? 'downloaded' : 'extracted';
        } else {
          // Recent: mostly discovered
          map[String(y)][String(m)] = Math.random() < 0.4 ? null : 'discovered';
        }
      }
    }
    return map;
  })(),
};

// ── Demo Animation Loop ──
let demoStep = 0;
function runDemoLoop() {
  if (!FORCE_DEMO) return;
  demoStep++;

  // Use the task-board-driven functions so board visits are visible
  switch (demoStep % 16) {
    case 1:
      editorAssignTask('reader', 'Extract features from Nov 2013');
      break;
    case 5:
      editorCollectResult('courier', 'Downloaded sim_ad_2004-10');
      break;
    case 9:
      editorAssignTask('scout', 'Find AD issues Jan-Mar 2015');
      break;
    case 13:
      editorHandleFailure('courier', '404 not found on archive.org');
      break;
  }
  setTimeout(runDemoLoop, 5000);
}

// ══════════════════════════════════════
// EDITOR BEHAVIOR SYSTEM
// ══════════════════════════════════════

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/** Hide all editor sprites, then show only the named one. */
function editorSetSprite(type) {
  const charEl = agentCharElements['editor'];
  if (!charEl) return;
  charEl.querySelectorAll('.char-img').forEach(img => img.style.display = 'none');
  const target = charEl.querySelector(`.char-${type}`);
  if (target) target.style.display = 'block';
}

/** Tap foot animation — alternates front/tap sprites. */
async function editorTapFoot() {
  if (editorBusy) return;
  editorBusy = true;
  const taps = 3 + Math.floor(Math.random() * 4); // 3–6 taps
  for (let i = 0; i < taps; i++) {
    editorSetSprite('tap');
    await sleep(300);
    editorSetSprite('front');
    await sleep(300);
  }
  editorBusy = false;
}

/** Quick blink — brief swap to blink sprite and back. */
async function editorBlink() {
  editorSetSprite('blink');
  await sleep(150);
  if (!editorBusy) editorSetSprite('front');
}

/** Check watch — show watch sprite for a couple seconds. */
async function editorCheckWatch() {
  if (editorBusy) return;
  editorBusy = true;
  editorSetSprite('watch');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2500);
  editorSetSprite('front');
  editorBusy = false;
}

/** Patrol — walk up the center aisle and back. */
async function editorPatrol() {
  if (editorBusy) return;
  editorBusy = true;
  const cfg = AGENT_CONFIG.editor;

  // Walk up the center aisle
  await walkEditorTo(50, 45, { finalSprite: 'back' });

  // Pause at top
  await sleep(1200);

  // Walk back down
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Study the boards — walk to each chalkboard, study them, return to center. */
async function editorStudyBoards() {
  if (editorBusy) return;
  editorBusy = true;
  const cfg = AGENT_CONFIG.editor;

  // Walk to Discovery Map (left wall) via aisle
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await walkEditorTo(DISCOVERY_MAP_POS.x, DISCOVERY_MAP_POS.y);

  // Study the map
  editorSetSprite('studying');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(3000);

  // Walk to Completed/Failed board (right chalkboard) — same row, horizontal
  await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y);

  editorSetSprite('studying');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2500);

  // Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Visit a specific agent — walk to their row, yellow glow exchange, return. */
async function editorVisitAgent(agentId) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;

  // Yellow glow on both Editor and target agent (hub-and-spoke engagement)
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }

  // Agent steps toward aisle to meet Editor
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk toward agent's row via center aisle
  await walkEditorTo(50, target.homeY);

  // Turn to face the agent and interact
  editorSetSprite('front');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2000);

  // Clear engagement glow
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');

  // Agent returns to desk
  moveAgentHome(agentId);

  // Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });
  editorBusy = false;
}

/** Gather reports — visit all workers in sequence (triggered by working status). */
let lastGatherTime = 0;
async function editorGatherReports() {
  if (editorBusy) return;
  // Cooldown: don't gather more than once every 90 seconds
  const now = Date.now();
  if (now - lastGatherTime < 90000) return;
  lastGatherTime = now;
  editorBusy = true;

  const workers = ['scout', 'courier', 'reader', 'detective'];
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];

  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(1000);

  for (const agentId of workers) {
    const target = AGENT_CONFIG[agentId];
    if (!target) continue;

    // Yellow glow on both Editor and target agent
    const targetChar = agentCharElements[agentId];
    if (editorChar) editorChar.classList.add('editor-engage');
    if (targetChar) {
      targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-rest');
      targetChar.classList.add('editor-engage', 'show-front');
    }

    // Agent steps toward aisle
    moveAgentTo(agentId, target.exitX, target.homeY, true);

    // Walk toward this agent's row
    const goingUp = target.homeY < cfg.homeY;
    editorSetSprite(goingUp ? 'back' : 'front');
    moveAgentTo('editor', 50, target.homeY, !goingUp);
    if (goingUp) editorSetSprite('back');
    await sleep(1500);

    // Interact
    editorSetSprite('front');
    updateSpeechBubble('editor', mirandaCurrentSpeech);
    await sleep(1500);

    // Clear engagement glow, agent returns to desk
    if (editorChar) editorChar.classList.remove('editor-engage');
    if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
    moveAgentHome(agentId);
  }

  // Return home
  editorSetSprite('front');
  moveAgentTo('editor', cfg.homeX, cfg.homeY, true);
  editorSetSprite('front');
  await sleep(1500);

  updateSpeechBubble('editor', mirandaCurrentSpeech);
  editorBusy = false;
}

/** Start the editor's task-board-driven behavior loop + background blinks. */
function initEditorBehavior() {
  scheduleEditorBehavior();
  scheduleEditorBlinks();
}

/** Schedule the next behavior check. Faster when there are queued events. */
function scheduleEditorBehavior() {
  const hasQueue = _editorActionQueue.length > 0;
  const delay = hasQueue
    ? 3000 + Math.random() * 3000    // 3-6s when events to process
    : 25000 + Math.random() * 20000; // 25-45s when idle
  editorBehaviorTimer = setTimeout(doEditorBehavior, delay);
}

// ── Task Board Diff System ──
// Tracks previous task_board snapshot to detect new assignments, completions, failures
let _prevTaskBoard = { in_flight: [], completed: [], failed: [] };
let _editorActionQueue = []; // { type: 'assign'|'collect'|'failure', agent, label }

/** Compare current task_board to previous snapshot. Queue editor actions for changes. */
function diffTaskBoard() {
  if (!currentState?.task_board) return;
  const board = currentState.task_board;

  const prevInFlight = new Set((_prevTaskBoard.in_flight || []).map(t => t.id || t.task_id));
  const prevCompleted = new Set((_prevTaskBoard.completed || []).map(t => t.id || t.task_id));
  const prevFailed = new Set((_prevTaskBoard.failed || []).map(t => t.id || t.task_id));

  // New tasks in flight = Editor assigned work
  for (const task of (board.in_flight || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevInFlight.has(tid)) {
      const agent = task.agent || task.assigned_to || '';
      _editorActionQueue.push({
        type: 'assign',
        agent: agent,
        label: task.goal || task.type || 'New task',
      });
    }
  }

  // New completed tasks = Editor collecting results
  for (const task of (board.completed || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevCompleted.has(tid)) {
      const agent = task.agent || task.completed_by || '';
      _editorActionQueue.push({
        type: 'collect',
        agent: agent,
        label: task.goal || task.type || 'Task complete',
      });
    }
  }

  // New failed tasks = Editor responding to failure
  for (const task of (board.failed || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevFailed.has(tid)) {
      const agent = task.agent || task.failed_by || '';
      _editorActionQueue.push({
        type: 'failure',
        agent: agent,
        label: task.error || task.goal || 'Task failed',
      });
    }
  }

  // Cap queue to prevent runaway if many events arrive at once
  if (_editorActionQueue.length > 6) {
    _editorActionQueue = _editorActionQueue.slice(-6);
  }

  _prevTaskBoard = JSON.parse(JSON.stringify(board));
}

/** Editor walks to board, picks up task, then walks to agent to assign it. */
async function editorAssignTask(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Step 1: Editor picks up clipboard at desk
  editorSetSprite('clipboard');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(800);

  // Step 2: Yellow glow on both — agent steps to aisle
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Step 3: Walk from board to agent's row via aisle with clipboard
  await walkEditorTo(50, target.homeY, { carrySprite: 'clipboard' });

  // Step 4: Face agent, deliver task
  editorSetSprite('front');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2500);

  // Step 5: Clear engagement, agent returns
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
  moveAgentHome(agentId);

  // Step 6: Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Editor walks to agent to collect a result (returns happy). */
async function editorCollectResult(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Yellow glow
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }

  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk to agent via aisle (empty-handed)
  await walkEditorTo(50, target.homeY);

  // Collect and show happy face
  editorSetSprite('happy');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2000);

  // Clear engagement
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
  moveAgentHome(agentId);

  // Walk to Completed board (right chalkboard) via aisle to log the result
  await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y, { carrySprite: 'clipboard' });

  editorSetSprite('clipboard');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(1800);

  // Walk home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Editor walks to agent to respond to a failure (concerned face, red glow). */
async function editorHandleFailure(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  // Red-tinted glow for failure (override yellow)
  if (editorChar) {
    editorChar.classList.add('collab-glow');
    editorChar.style.setProperty('--glow-color', '#e74c3c');
  }
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-rest', 'hub-done');
    targetChar.classList.add('collab-glow', 'show-front');
    targetChar.style.setProperty('--glow-color', '#e74c3c');
  }

  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk to agent via aisle
  await walkEditorTo(50, target.homeY);

  // Show failure/concerned face
  editorSetSprite('failure');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(2500);

  // Clear glow
  if (editorChar) { editorChar.classList.remove('collab-glow'); editorChar.style.removeProperty('--glow-color'); }
  if (targetChar) { targetChar.classList.remove('collab-glow', 'show-front'); targetChar.style.removeProperty('--glow-color'); }
  moveAgentHome(agentId);

  // Walk to Completed/Failed board (right chalkboard) via aisle to log the failure
  await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y, { carrySprite: 'clipboard' });

  editorSetSprite('clipboard');
  updateSpeechBubble('editor', mirandaCurrentSpeech);
  await sleep(1800);

  // Walk home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Pick and execute editor behavior based on task board events. */
async function doEditorBehavior() {
  if (editorBusy) {
    scheduleEditorBehavior();
    return;
  }

  // Diff the task board for new events
  diffTaskBoard();

  if (_editorActionQueue.length > 0) {
    const action = _editorActionQueue.shift();
    const agentId = action.agent?.toLowerCase();

    // Only visit if we know this agent
    if (agentId && AGENT_CONFIG[agentId] && agentId !== 'editor') {
      switch (action.type) {
        case 'assign':
          await editorAssignTask(agentId, action.label);
          break;
        case 'collect':
          await editorCollectResult(agentId, action.label);
          break;
        case 'failure':
          await editorHandleFailure(agentId, action.label);
          break;
      }
    }
  } else {
    // No task board events — check editor_state for strategic assessment
    const editorState = currentState?.agents?.find(a => a.id === 'editor')?.editor_state;
    if (editorState === 'assessing') {
      // Strategic assessment: walk to boards and study them
      await editorStudyBoards();
    } else {
      // True idle: subtle animations
      const roll = Math.random();
      if (roll < 0.25) {
        await editorTapFoot();
      } else if (roll < 0.45) {
        await editorCheckWatch();
      } else if (roll < 0.70) {
        // Walk to chalkboards and study them
        await editorStudyBoards();
      } else {
        // Occasional patrol up the aisle and back
        await editorPatrol();
      }
    }
  }

  scheduleEditorBehavior();
}

/** Schedule random blinks independent of main behavior. */
function scheduleEditorBlinks() {
  const delay = 3000 + Math.random() * 5000; // 3–8 seconds
  setTimeout(async () => {
    if (!editorBusy) {
      await editorBlink();
    }
    scheduleEditorBlinks();
  }, delay);
}

// ── Fetch & Poll ──
async function fetchStatus() {
  if (FORCE_DEMO) {
    DEMO_DATA.timestamp = new Date().toISOString(); // Keep demo "live"
    dataSource = 'demo';
    currentState = DEMO_DATA;
    renderAll(DEMO_DATA);
    if (demoStep === 0) setTimeout(runDemoLoop, 3000);
    return;
  }

  try {
    const resp = await fetch(STATUS_URL + '?t=' + Date.now());
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    dataSource = 'live';
    currentState = data;
    lastDataTimestamp = data.timestamp;
    renderAll(data);
  } catch (e) {
    try {
      const demoResp = await fetch('demo-status.json?t=' + Date.now());
      if (demoResp.ok) {
        const demoData = await demoResp.json();
        dataSource = 'live'; // demo-status.json is still "real" data
        currentState = demoData;
        lastDataTimestamp = demoData.timestamp;
        renderAll(demoData);
        return;
      }
    } catch (_) {}
    console.log('Using built-in demo data:', e.message);
    if (dataSource !== 'demo') showToast('SERVER OFFLINE — using demo data', 'info', 4000);
    dataSource = 'demo';
    DEMO_DATA.timestamp = new Date().toISOString();
    currentState = DEMO_DATA;
    renderAll(DEMO_DATA);
  }
}

// ── Sound ──
function initSound() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function toggleSound() {
  const btn = document.getElementById('sound-toggle');
  soundOn = !soundOn;
  if (soundOn) {
    if (!audioCtx) initSound();
    btn.textContent = 'SFX ON';
    btn.classList.add('active');
    startAmbient();
  } else {
    btn.textContent = 'SFX OFF';
    btn.classList.remove('active');
    stopAmbient();
  }
}
function startAmbient() {
  if (!audioCtx || ambientOsc) return;
  ambientOsc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  ambientOsc.type = 'sine'; ambientOsc.frequency.value = 80;
  gain.gain.value = 0.02;
  ambientOsc.connect(gain); gain.connect(audioCtx.destination);
  ambientOsc.start();
}
function stopAmbient() {
  if (ambientOsc) { ambientOsc.stop(); ambientOsc = null; }
}
function playCollabSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(330, audioCtx.currentTime);
  osc.frequency.linearRampToValueAtTime(660, audioCtx.currentTime + 0.15);
  gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.2);
}

// ── Scale to fit window ──
function scaleDashboard() {
  const el = document.querySelector('.dashboard');
  // Scale to fill viewport width exactly — no side gaps
  const scale = window.innerWidth / 1920;
  // Stretch height to fill viewport
  const naturalHeight = window.innerHeight / scale;
  el.style.height = naturalHeight + 'px';
  el.style.transform = `scale(${scale})`;
  el.style.marginLeft = '0px';
  el.style.marginTop = '0px';
  requestAnimationFrame(syncPanelHeight);
}
function syncPanelHeight() {
  // No-op: panels now stretch to full dashboard height via grid
}
scaleDashboard();
window.addEventListener('resize', scaleDashboard);

// ── Init ──
init();
</script>
</body>
</html>
