<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Office</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
/* ── Reset & Base ── */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --gold: #f5c842;
  --gold-dark: #8B6914;
  --bg-dark: #1a1a28;
  --bg-darker: #111118;
  --bg-panel: #1a0e2e;
  --border: #333;
  --border-subtle: #2a2a3a;
  --text: #e0e0e0;
  --text-dim: #888;
  --text-muted: #555;
  --scout-color: #e74c3c;
  --courier-color: #3498db;
  --reader-color: #2ecc71;
  --detective-color: #9b59b6;
  --editor-color: #f5c842;
  --designer-color: #e91e63;
  --researcher-color: #e67e22;
}

body {
  font-family: 'Press Start 2P', monospace;
  background: var(--bg-dark);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  image-rendering: pixelated;
}

/* ══════════════════════════════════════
   3-COLUMN DASHBOARD GRID
   ══════════════════════════════════════ */
.dashboard {
  display: grid;
  grid-template-columns: 1.2fr 2fr 1.3fr;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "top    top    top"
    "left   center right";
  width: 1920px;
  height: 1080px;
  gap: 0;
  transform-origin: top left;
}

/* ── Top Bar ── */
.top-bar {
  grid-area: top;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  background: linear-gradient(180deg, rgba(245,200,66,0.08) 0%, transparent 100%);
  border-bottom: 2px solid var(--border);
}
.top-bar-title {
  font-size: 14px;
  color: var(--gold);
  text-shadow: 1px 1px 0 var(--gold-dark);
  letter-spacing: 3px;
  white-space: nowrap;
}

/* ── Scene Stats Overlay (over brick wall) ── */
.scene-stats-overlay {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  display: flex;
  gap: 4px;
  pointer-events: none;
  max-width: 100%;
}
.top-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  padding: 5px 7px;
  background: rgba(0,0,0,0.6);
  border: 1px solid rgba(245,200,66,0.25);
  backdrop-filter: blur(4px);
  pointer-events: auto;
}
.top-stat-value {
  font-size: 13px;
  color: var(--gold);
}
.top-stat-label {
  font-size: 7px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0px;
}
.top-stat.has-details {
  cursor: context-menu;
  border-color: rgba(245,200,66,0.5);
}
.top-stat.has-details:hover {
  border-color: var(--gold);
  background: rgba(245,200,66,0.08);
}

/* ── Left Panel ── */
.panel-left {
  grid-area: left;
  background: var(--bg-panel);
  border-right: 2px solid var(--border);
  overflow: hidden;
  padding: 16px 16px 0 16px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ── Center (Office Scene) ── */
.center-scene {
  grid-area: center;
  overflow: hidden;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  background: var(--bg-darker);
}

/* ── Right Panel ── */
.panel-right {
  grid-area: right;
  background: var(--bg-panel);
  border-left: 2px solid var(--border);
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

/* ── Panel Section ── */
.panel-section {
  flex-shrink: 0;
}
.panel-section h3 {
  font-size: 9px;
  color: var(--gold);
  letter-spacing: 1px;
  margin-bottom: 10px;
  text-transform: uppercase;
  border-bottom: 1px solid var(--border-subtle);
  padding-bottom: 6px;
}

/* ══════════════════════════════════════
   LEFT PANEL — PIPELINE FUNNEL
   ══════════════════════════════════════ */
.pipeline-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}
.pipeline-bar-wrap {
  flex: 1;
  height: 12px;
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border-subtle);
  overflow: hidden;
}
.pipeline-bar {
  height: 100%;
  transition: width 0.6s ease;
}
.pipeline-count {
  font-size: 9px;
  color: var(--text);
  min-width: 32px;
  text-align: right;
}
.pipeline-label {
  font-size: 7px;
  color: var(--text-dim);
  min-width: 72px;
}

/* ══════════════════════════════════════
   LEFT PANEL — QUEUE DEPTHS
   ══════════════════════════════════════ */
.queue-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
  font-size: 7px;
}
.queue-dot {
  width: 8px;
  height: 8px;
  border-radius: 0;
  flex-shrink: 0;
}
.queue-count {
  color: var(--text);
  min-width: 24px;
  text-align: right;
  font-size: 9px;
}
.queue-label {
  color: var(--text-dim);
  font-size: 7px;
}

/* ══════════════════════════════════════
   LEFT PANEL — EDITOR INBOX
   ══════════════════════════════════════ */
.inbox-scroll {
  flex: 1;
  overflow-y: auto;
}
.inbox-msg {
  padding: 5px 7px;
  margin-bottom: 4px;
  background: rgba(245,200,66,0.04);
  border-left: 3px solid var(--gold-dark);
  font-size: 10px;
  line-height: 1.6;
}
.inbox-msg.alert {
  border-left-color: #e74c3c;
  background: rgba(231,76,60,0.06);
}
.inbox-msg-time {
  color: var(--text-muted);
  font-size: 9px;
  margin-bottom: 2px;
}
.inbox-msg-text {
  color: var(--text);
}
.inbox-msg.human {
  border-left-color: #3498db;
  background: rgba(52,152,219,0.06);
}
.inbox-msg.human .inbox-msg-time::before {
  content: 'YOU  ';
  color: #3498db;
}
.inbox-msg.reply {
  border-left-color: #2ecc71;
  background: rgba(46,204,113,0.08);
}
.inbox-msg.reply .inbox-msg-time::before {
  content: 'EDITOR  ';
  color: #2ecc71;
}
.inbox-empty {
  font-size: 6px;
  color: var(--text-dim);
  padding: 4px 0;
}
.inbox-input-wrap {
  display: flex;
  gap: 4px;
  padding-top: 10px;
  margin-top: 8px;
  border-top: 1px solid var(--border-subtle);
  flex-shrink: 0;
}
.inbox-input {
  flex: 1;
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  padding: 8px 10px;
  background: rgba(0,0,0,0.4);
  border: 1px solid var(--border-subtle);
  color: var(--text);
  outline: none;
}
.inbox-input:focus {
  border-color: var(--gold);
}
.inbox-input::placeholder {
  color: var(--text-muted);
  font-size: 8px;
}
.inbox-send {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  padding: 8px 12px;
  background: rgba(245,200,66,0.12);
  border: 1px solid var(--gold-dark);
  color: var(--gold);
  cursor: pointer;
  flex-shrink: 0;
  transition: background 0.2s;
}
.inbox-send:hover {
  background: rgba(245,200,66,0.25);
}

/* ══════════════════════════════════════
   LEFT PANEL — NOW PROCESSING
   ══════════════════════════════════════ */
.now-row {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 7px;
  line-height: 1.6;
}
.now-dot {
  width: 8px;
  height: 8px;
  flex-shrink: 0;
  margin-top: 3px;
}
.now-dot.active {
  animation: dot-pulse 1s infinite;
}
.now-agent {
  color: var(--text);
  font-size: 8px;
  min-width: 60px;
  flex-shrink: 0;
}
.now-task {
  color: var(--text-dim);
  font-size: 7px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* ══════════════════════════════════════
   RIGHT PANEL — ACTIVITY LOG
   ══════════════════════════════════════ */
.log-filters {
  display: flex;
  gap: 3px;
  flex-wrap: wrap;
  margin-bottom: 6px;
}
.log-filter-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 3px 5px;
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border-subtle);
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.2s;
}
.log-filter-btn:hover { color: var(--text); border-color: var(--text-dim); }
.log-filter-btn.active { color: var(--gold); border-color: var(--gold-dark); background: rgba(245,200,66,0.08); }

.log-scroll {
  max-height: 200px;
  overflow-y: auto;
}
.log-entry {
  font-size: 7px;
  padding: 4px 0;
  border-bottom: 1px solid #1e1e2e;
  display: flex;
  gap: 8px;
  line-height: 1.6;
}
.log-entry:last-child { border-bottom: none; }
.log-time { color: var(--text-muted); flex-shrink: 0; width: 38px; }
.log-agent { flex-shrink: 0; width: 68px; }
.log-event { color: #aaa; }

/* ══════════════════════════════════════
   RIGHT PANEL — NOTABLE FINDS
   ══════════════════════════════════════ */
.find-card {
  padding: 6px 8px;
  margin-bottom: 5px;
  background: rgba(255,255,255,0.02);
  border-left: 3px solid #555;
  transition: all 0.4s ease;
}
.find-card.epstein_match { border-left-color: #e74c3c; background: rgba(231,76,60,0.06); }
.find-card.epstein_match.new-find { animation: findPulse 1.5s ease 2; }
@keyframes findPulse {
  0%, 100% { background: rgba(231,76,60,0.06); }
  50% { background: rgba(231,76,60,0.18); }
}
.find-name {
  font-size: 8px;
  color: var(--text);
  margin-bottom: 3px;
}
.find-card.epstein_match .find-name::before { content: '\26A0 '; color: #e74c3c; }
.find-meta {
  font-size: 7px;
  color: var(--text-dim);
}
/* ── Find Pipeline (DET → RES → EDT) ── */
.find-pipeline {
  display: flex;
  gap: 3px;
  align-items: center;
  margin-top: 4px;
}
.pipe-stage {
  font-size: 6px;
  display: flex;
  align-items: center;
  gap: 2px;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.pipe-stage-label {
  font-size: 5px;
  color: var(--text-muted);
}
.pipe-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  border: 1px solid currentColor;
  flex-shrink: 0;
}
.pipe-dot.complete { background: currentColor; }
.pipe-dot.active { animation: pipePulse 1.5s ease infinite; }
@keyframes pipePulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(0.8); }
}
.pipe-arrow {
  font-size: 6px;
  color: var(--text-dim);
  margin: 0 1px;
}
.pipe-arrow.dim { opacity: 0.2; }
.pipe-verdict {
  font-size: 5px;
  letter-spacing: 0.3px;
}

/* ══════════════════════════════════════
   RIGHT PANEL — DATA QUALITY
   ══════════════════════════════════════ */
.quality-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 5px;
}
.quality-label {
  font-size: 7px;
  color: var(--text-dim);
  min-width: 70px;
}
.quality-bar-wrap {
  flex: 1;
  height: 10px;
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border-subtle);
  overflow: hidden;
}
.quality-bar {
  height: 100%;
  background: var(--gold);
  transition: width 0.6s ease;
}
.quality-pct {
  font-size: 8px;
  color: var(--text);
  min-width: 32px;
  text-align: right;
}

/* ══════════════════════════════════════
   RIGHT PANEL — DISCOVERY COVERAGE MAP
   ══════════════════════════════════════ */
.coverage-grid {
  display: grid;
  grid-template-columns: 28px repeat(12, 1fr);
  gap: 1px;
  font-size: 5px;
}
.coverage-month-header {
  text-align: center;
  color: var(--text-dim);
  font-size: 5px;
  padding: 1px 0;
}
.coverage-year-label {
  text-align: right;
  padding-right: 3px;
  color: var(--text-dim);
  font-size: 5px;
  line-height: 7px;
}
.coverage-cell {
  width: 100%;
  height: 6px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.02);
}
.coverage-cell.discovered { background: var(--scout-color); opacity: 0.7; }
.coverage-cell.downloaded { background: var(--courier-color); opacity: 0.8; }
.coverage-cell.extracted { background: var(--reader-color); opacity: 0.9; }
.coverage-cell.error, .coverage-cell.extraction_error { background: #e74c3c; opacity: 0.4; }
.coverage-cell.skipped_pre1988 { background: rgba(255,255,255,0.08); }
.coverage-cell.no_pdf { background: rgba(255,255,255,0.08); }
.coverage-legend {
  display: flex;
  gap: 8px;
  margin-top: 4px;
  font-size: 6px;
  color: var(--text-dim);
}
.coverage-legend-item {
  display: flex;
  align-items: center;
  gap: 3px;
}
.coverage-legend-swatch {
  width: 8px;
  height: 6px;
  display: inline-block;
}

/* ══════════════════════════════════════
   OFFICE SCENE — LAYERED SYSTEM
   ══════════════════════════════════════ */

.office-scene-wrapper {
  position: relative;
  width: 100%;
}

.office-scene {
  position: relative;
  width: 100%;
  aspect-ratio: 1792 / 2110;
  background: var(--bg-darker);
  overflow: hidden;
}

/* Layer 0: Room background */
.office-scene .layer-bg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  image-rendering: pixelated;
}

/* ── Overlay layers (positioned over the scene) ── */
.overlay-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  overflow: visible;
}

/* Layer 1: Chalkboard overlays (back wall) */
#chalkboard-layer { z-index: 1; pointer-events: none; }
#chalkboard-layer .chalkboard { pointer-events: auto; }

/* Layer 2: Mid-row desks (Scout, Courier) */
#desks-mid-layer { z-index: 2; overflow: hidden; }

/* Layer 3: Mid-row agents (Scout, Courier) */
#agents-mid-layer { z-index: 3; }
#agents-mid-layer .agent-char { pointer-events: auto; }

/* Layer 4: Front-row desks (Reader, Detective) */
#desks-front-layer { z-index: 4; overflow: hidden; }

/* Layer 5: Front-row agents (Reader, Detective) */
#agents-front-layer { z-index: 5; }
#agents-front-layer .agent-char { pointer-events: auto; }

/* Layer 6: Editor (roams the aisle — above most agents) */
#editor-layer { z-index: 6; }
#editor-layer .agent-char { pointer-events: auto; }

/* Layer 7: Bottom-row desk (Designer — overlaps Detective agent for depth) */
#desks-bottom-layer { z-index: 7; overflow: hidden; }

/* Layer 8: Bottom-row agent (Designer — highest agent z-index) */
#agents-bottom-layer { z-index: 8; }
#agents-bottom-layer .agent-char { pointer-events: auto; }

/* Layer 9: UI elements (speech bubbles, nametags) */
#ui-layer { z-index: 9; }

/* ══════════════════════════════════════
   CHALKBOARD TASK BOARDS (on back wall)
   ══════════════════════════════════════ */
.chalkboard {
  position: absolute;
  overflow: hidden;
  padding: 14px 10px 6px;
  font-family: 'Press Start 2P', monospace;
}
.chalkboard-left {
  left: 0.8%;
  top: 9%;
  width: 38%;
  height: 14%;
}
.chalkboard-right {
  left: 61%;
  top: 9%;
  width: 38%;
  height: 14%;
}
.chalk-title {
  font-size: 5px;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-bottom: 4px;
  text-shadow: 0 0 4px rgba(255,255,255,0.3);
  text-align: center;
  border-bottom: 1px solid rgba(255,255,255,0.25);
  padding-bottom: 3px;
}
.chalk-list {
  overflow-y: auto;
  max-height: calc(100% - 18px);
}
.chalk-list::-webkit-scrollbar { width: 2px; }
.chalk-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); }
.chalk-item {
  display: flex;
  align-items: baseline;
  gap: 4px;
  padding: 2px 0;
  font-size: 4px;
  line-height: 1.6;
  color: #fff;
  text-shadow: 0 0 3px rgba(255,255,255,0.2);
  border-bottom: 1px solid rgba(255,255,255,0.1);
}
.chalk-item:last-child { border-bottom: none; }
.chalk-agent {
  flex-shrink: 0;
  min-width: 36px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.chalk-goal {
  color: rgba(255, 255, 255, 0.85);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.chalk-item.completed .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.completed .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-item.failed .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.failed .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-item.in-flight .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.exhausted .chalk-agent { color: rgba(255, 255, 255, 0.75); text-decoration: line-through; }
.chalk-item.exhausted .chalk-goal { color: rgba(255, 255, 255, 0.5); text-decoration: line-through; }
.chalk-item.stuck .chalk-agent { color: rgba(255, 255, 255, 0.95); }
.chalk-item.stuck .chalk-goal { color: rgba(255, 255, 255, 0.7); }
.chalk-section-label {
  font-size: 3.5px;
  color: rgba(255,255,255,0.45);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 3px 0 1px 0;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
.chalk-count {
  font-size: 3.5px;
  color: rgba(255,255,255,0.35);
  margin-left: auto;
  flex-shrink: 0;
}
.chalk-empty {
  font-size: 4px;
  color: rgba(255,255,255,0.6);
  text-align: center;
  padding: 8px 0;
  font-style: italic;
}

/* ── CSS Fallback Floor (no bg image) ── */
.office-floor {
  position: absolute;
  inset: 0;
}
.office-floor::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 48px),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 48px);
  background-color: #1e1e2e;
}
.corridor {
  position: absolute;
  left: 38%; width: 24%;
  top: 0; bottom: 0;
  background: rgba(255,255,255,0.02);
  border-left: 1px dashed rgba(255,255,255,0.06);
  border-right: 1px dashed rgba(255,255,255,0.06);
}
.door {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 48px; height: 8px;
  background: #5a3a1a;
  border-bottom: 2px solid #3a2510;
}
.door::after {
  content: 'DOOR';
  position: absolute;
  bottom: -14px; left: 50%;
  transform: translateX(-50%);
  font-size: 5px;
  color: rgba(255,255,255,0.15);
  font-family: 'Press Start 2P', monospace;
  white-space: nowrap;
}

/* ── Desk Overlay Images ── */
.desk-overlay {
  position: absolute;
  image-rendering: pixelated;
  pointer-events: none;
}
/* Bottom row — Designer & Researcher */
.desk-overlay[data-desk="designer"] {
  width: 25.92%;
  right: 10%;
  top: 72%;
}
.desk-overlay[data-desk="researcher"] {
  width: 27.78%;
  left: 9%;
  top: 77%;
}
/* Mid row — Scout & Courier */
.desk-overlay[data-desk="scout"] {
  width: 24%;
  left: 10%;
  top: 42%;
}
.desk-overlay[data-desk="courier"] {
  width: 28.51%;
  right: 6%;
  top: 42%;
}
/* Front row — Reader & Detective */
.desk-overlay[data-desk="reader"] {
  width: 24%;
  left: 10%;
  top: 58%;
}
.desk-overlay[data-desk="detective"] {
  width: 24%;
  right: 10%;
  top: 58%;
}

/* ── Agent Character ── */
.agent-char {
  position: absolute;
  transition: left 1.5s ease-in-out, top 1.5s ease-in-out;
  cursor: pointer;
}
/* Ground shadow under each agent */
.agent-char::after {
  content: '';
  position: absolute;
  bottom: -4px;
  left: 50%;
  transform: translateX(-50%);
  width: 60%;
  height: 12%;
  background: radial-gradient(ellipse, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.35) 50%, transparent 70%);
  border-radius: 50%;
  pointer-events: none;
}

/* Character images */
.char-img {
  height: 100%;
  width: auto;
  image-rendering: pixelated;
  display: block;
  margin: 0 auto;
}
.char-img.char-front { display: none; }
.char-img.char-back { display: block; }

/* When collaborating, show front */
.agent-char.show-front .char-front { display: block; }
.agent-char.show-front .char-back { display: none; }

/* Editor extra pose sprites (hidden by default) */
.char-img.char-blink,
.char-img.char-tap,
.char-img.char-watch,
.char-img.char-failure,
.char-img.char-clipboard,
.char-img.char-studying { display: none; }

/* ── Status Animations ── */
.agent-char.anim-idle .char-img {
  animation: idle-bob 2.5s ease-in-out infinite;
}
.agent-char.anim-working .char-img {
  animation: working-bounce 0.5s steps(2) infinite;
}
.agent-char.anim-done .char-img {
  animation: done-relax 3s ease-in-out infinite;
}
.agent-char.anim-error .char-img {
  animation: error-shake 0.4s ease-in-out infinite;
}

@keyframes idle-bob {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}
@keyframes working-bounce {
  0% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}
@keyframes done-relax {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-1px); }
}
@keyframes error-shake {
  0%, 100% { transform: translateY(0); }
  25% { transform: translateX(3px); }
  75% { transform: translateX(-3px); }
}

/* ── Particles ── */
.particle-container {
  position: absolute;
  top: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 20px;
  pointer-events: none;
  overflow: visible;
}
.particle {
  position: absolute;
  width: 4px; height: 4px;
  animation: particle-float 1.5s ease-out infinite;
}
.particle:nth-child(1) { left: 25%; animation-delay: 0s; }
.particle:nth-child(2) { left: 50%; animation-delay: 0.4s; }
.particle:nth-child(3) { left: 75%; animation-delay: 0.8s; }
.agent-char.anim-working .particle { background: rgba(255,255,255,0.5); }
.agent-char.anim-done .particle { background: #2ecc71; animation-duration: 2.5s; }
.agent-char.anim-error .particle { background: #e74c3c; animation-duration: 0.8s; }
.agent-char.anim-idle .particle { display: none; }

@keyframes particle-float {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-16px) scale(0.5); }
}

/* ── UI Elements (Speech Bubble + Nametag) ── */
.agent-ui {
  position: absolute;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Speech Bubble */
.speech-bubble {
  position: absolute;
  bottom: calc(100% + 6px);
  left: 50%;
  transform: translateX(-50%);
  background: #fff;
  color: #222;
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  line-height: 1.6;
  padding: 6px 10px;
  white-space: normal;
  word-wrap: break-word;
  width: max-content;
  max-width: 280px;
  border: 2px solid #333;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease;
  box-shadow: -2px 0 0 #333, 2px 0 0 #333, 0 -2px 0 #333, 0 2px 0 #333;
}
.speech-bubble::after {
  content: '';
  position: absolute;
  top: 100%; left: 50%;
  transform: translateX(-50%);
  width: 0; height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 6px solid #fff;
  filter: drop-shadow(0 2px 0 #333);
}
.speech-bubble.visible {
  opacity: 1;
  animation: bubble-pop 0.25s ease-out;
}

@keyframes bubble-pop {
  0% { transform: translateX(-50%) scale(0.7); opacity: 0; }
  100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

/* Agent Name Tag */
.agent-nametag {
  position: absolute;
  top: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  white-space: nowrap;
  padding: 2px 6px;
  background: rgba(0,0,0,0.8);
  border: 1px solid;
  pointer-events: none;
}

/* Cycle count + progress shown under nametag */
.agent-nametag .tag-stats {
  display: block;
  font-size: 4px;
  opacity: 0.7;
  margin-top: 1px;
  letter-spacing: 0;
}

/* Status Indicator Dot */
.status-dot {
  position: absolute;
  top: -4px;
  right: -4px;
  width: 8px; height: 8px;
  border: 1px solid rgba(0,0,0,0.5);
}
.status-dot.working { background: #27ae60; animation: dot-pulse 1s infinite; }
.status-dot.idle    { background: #555; }
.status-dot.done    { background: #f5c842; }
.status-dot.error   { background: #e74c3c; animation: dot-pulse 0.5s infinite; }

@keyframes dot-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ── Collaboration Glow — traces sprite silhouette in initiator's color ── */
.agent-char.collab-glow {
  filter:
    drop-shadow(0 0 3px var(--glow-color, #f5c842))
    drop-shadow(0 0 7px var(--glow-color, #f5c842))
    drop-shadow(0 0 14px var(--glow-color, #f5c842));
  animation: collab-glow-pulse 1.2s ease-in-out infinite;
}
@keyframes collab-glow-pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

/* ── Hub-and-Spoke: Working Agent (back view, pulsing agent-color outline) ── */
.agent-char.hub-working {
  filter:
    drop-shadow(0 0 2px var(--agent-color, #888))
    drop-shadow(0 0 5px var(--agent-color, #888));
  animation: hub-work-pulse 2s ease-in-out infinite;
}
.agent-char.hub-working .char-front { display: none !important; }
.agent-char.hub-working .char-back { display: block !important; }

@keyframes hub-work-pulse {
  0%, 100% { filter: drop-shadow(0 0 2px var(--agent-color, #888)) drop-shadow(0 0 5px var(--agent-color, #888)); }
  50% { filter: drop-shadow(0 0 3px var(--agent-color, #888)) drop-shadow(0 0 9px var(--agent-color, #888)); }
}

/* ── Hub-and-Spoke: Waiting Agent (front view, no glow) ── */
.agent-char.hub-waiting {
  filter: none;
}
.agent-char.hub-waiting .char-front { display: block !important; }
.agent-char.hub-waiting .char-back { display: none !important; }
.agent-char.hub-waiting .char-waiting { display: none !important; }

/* ── Hub-and-Spoke: Bored Agent (waiting sprite, no glow) ── */
.char-img.char-waiting { display: none; }
.agent-char.hub-bored {
  filter: none;
}
.agent-char.hub-bored .char-front { display: none !important; }
.agent-char.hub-bored .char-back { display: none !important; }
.agent-char.hub-bored .char-waiting { display: block !important; }

/* ── Hub-and-Spoke: Done Agent (relaxing sprite, subtle green glow) ── */
.char-img.char-done { display: none; }
.agent-char.hub-done {
  filter:
    drop-shadow(0 0 2px rgba(46, 204, 113, 0.4))
    drop-shadow(0 0 6px rgba(46, 204, 113, 0.2));
}
.agent-char.hub-done .char-front { display: none !important; }
.agent-char.hub-done .char-back { display: none !important; }
.agent-char.hub-done .char-waiting { display: none !important; }
.agent-char.hub-done .char-done { display: block !important; }

/* ── Hub-and-Spoke: Editor Engagement (yellow glow on both) ── */
.agent-char.editor-engage {
  filter:
    drop-shadow(0 0 4px #f5c842)
    drop-shadow(0 0 10px #f5c842)
    drop-shadow(0 0 18px #f5c842);
  animation: editor-engage-pulse 1s ease-in-out infinite;
}
@keyframes editor-engage-pulse {
  0%, 100% { opacity: 0.85; }
  50% { opacity: 1; }
}

/* ══════════════════════════════════════
   LIVE / STALE INDICATOR
   ══════════════════════════════════════ */
.live-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  font-size: 7px;
  letter-spacing: 1px;
  border: 1px solid;
  margin-left: 16px;
}
.live-badge .live-dot {
  width: 6px; height: 6px;
  border-radius: 0;
}
.live-badge.live {
  color: #27ae60;
  border-color: #27ae60;
}
.live-badge.live .live-dot {
  background: #27ae60;
  animation: dot-pulse 1s infinite;
}
.live-badge.stale {
  color: #f39c12;
  border-color: #f39c12;
}
.live-badge.stale .live-dot {
  background: #f39c12;
}
.live-badge.offline {
  color: #e74c3c;
  border-color: #e74c3c;
}
.live-badge.offline .live-dot {
  background: #e74c3c;
  animation: dot-pulse 0.5s infinite;
}

/* ══════════════════════════════════════
   AGENT ERROR OVERLAY
   ══════════════════════════════════════ */
.agent-char.has-error::before {
  content: '!';
  position: absolute;
  top: -10px;
  right: -4px;
  width: 16px; height: 16px;
  background: #e74c3c;
  color: #fff;
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 20;
  animation: error-shake 0.4s ease-in-out infinite;
}
/* Error tooltip on hover */
.agent-char.has-error[data-error]::after {
  content: attr(data-error);
  position: absolute;
  top: -28px;
  left: 50%;
  transform: translateX(-50%);
  background: #e74c3c;
  color: #fff;
  font-family: 'Press Start 2P', monospace;
  font-size: 4px;
  line-height: 1.4;
  padding: 3px 6px;
  white-space: nowrap;
  max-width: 180px;
  overflow: hidden;
  text-overflow: ellipsis;
  z-index: 30;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
}
.agent-char.has-error[data-error]:hover::after {
  opacity: 1;
}
.agent-char.is-paused .char-img {
  filter: grayscale(60%) brightness(0.6);
}

/* ══════════════════════════════════════
   THROUGHPUT & COST SECTIONS
   ══════════════════════════════════════ */
.metric-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 5px;
  font-size: 7px;
}
.metric-label {
  color: var(--text-dim);
  min-width: 80px;
}
.metric-value {
  color: var(--text);
  font-size: 9px;
  text-align: right;
}
.metric-value.gold { color: var(--gold); }
.metric-value.green { color: #27ae60; }

/* ══════════════════════════════════════
   SKILLS MODAL
   ══════════════════════════════════════ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 100;
  display: none;
  align-items: center;
  justify-content: center;
}
.modal-overlay.visible {
  display: flex;
}
.modal {
  background: var(--bg-panel);
  border: 2px solid var(--gold-dark);
  width: 600px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}
.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-subtle);
}
.modal-title {
  font-size: 9px;
  color: var(--gold);
  letter-spacing: 1px;
}
.modal-close {
  font-family: 'Press Start 2P', monospace;
  font-size: 8px;
  background: none;
  border: 1px solid var(--border-subtle);
  color: var(--text-dim);
  padding: 4px 8px;
  cursor: pointer;
}
.modal-close:hover { color: var(--text); border-color: var(--text-dim); }
.modal-tabs {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--border-subtle);
  overflow-x: auto;
}
.modal-tab {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  padding: 8px 12px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--text-dim);
  cursor: pointer;
  white-space: nowrap;
}
.modal-tab:hover { color: var(--text); }
.modal-tab.active {
  color: var(--gold);
  border-bottom-color: var(--gold);
}
.modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}
.modal-body pre {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  line-height: 2;
  color: var(--text);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* ══════════════════════════════════════
   AGENT CONTROL BUTTONS (floating at cursor)
   ══════════════════════════════════════ */
.agent-controls-popup {
  position: fixed;
  display: none;
  gap: 6px;
  z-index: 200;
  pointer-events: auto;
  padding: 6px;
  background: rgba(0,0,0,0.9);
  border: 1px solid var(--gold-dark);
}
.agent-controls-popup.visible {
  display: flex;
}
.agent-ctrl-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  padding: 8px 14px;
  background: rgba(0,0,0,0.95);
  border: 2px solid var(--border-subtle);
  color: var(--text-dim);
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
}
.agent-ctrl-btn:hover {
  color: var(--gold);
  border-color: var(--gold-dark);
  background: rgba(245,200,66,0.12);
}
/* Button colors set dynamically via --agent-color */
.agent-ctrl-btn.pause-btn,
.agent-ctrl-btn.resume-btn,
.agent-ctrl-btn.skills-btn {
  border-color: var(--agent-color, #888);
  color: var(--agent-color, #888);
}
.agent-ctrl-btn:hover {
  background: color-mix(in srgb, var(--agent-color, #888) 15%, transparent);
}

/* ── Editor listening/happy sprite states ── */
.char-img.char-listen,
.char-img.char-happy { display: none; }

/* ── Sound Toggle ── */
.sound-toggle {
  position: fixed;
  bottom: 16px; right: 16px;
  z-index: 50;
  background: rgba(0,0,0,0.7);
  border: 2px solid var(--border);
  color: var(--text-dim);
  font-family: 'Press Start 2P', monospace;
  font-size: 6px;
  padding: 5px 8px;
  cursor: pointer;
  transition: color 0.2s;
}
.sound-toggle:hover { color: var(--gold); }
.sound-toggle.active { color: #27ae60; border-color: #27ae60; }

/* ── Scrollbars ── */
.panel-left::-webkit-scrollbar,
.panel-right::-webkit-scrollbar,
.log-scroll::-webkit-scrollbar { width: 4px; }
.panel-left::-webkit-scrollbar-track,
.panel-right::-webkit-scrollbar-track,
.log-scroll::-webkit-scrollbar-track { background: transparent; }
.panel-left::-webkit-scrollbar-thumb,
.panel-right::-webkit-scrollbar-thumb,
.log-scroll::-webkit-scrollbar-thumb { background: #333; }

/* ── Toast Notifications ── */
.toast-container {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column-reverse;
  gap: 6px;
  pointer-events: none;
}
.toast {
  font-family: 'Press Start 2P', monospace;
  font-size: 7px;
  padding: 8px 16px;
  border: 1px solid;
  background: var(--bg-darker);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s, transform 0.3s;
  pointer-events: auto;
  white-space: nowrap;
}
.toast.visible { opacity: 1; transform: translateY(0); }
.toast.success { color: #27ae60; border-color: #27ae60; }
.toast.error { color: #e74c3c; border-color: #e74c3c; }
.toast.info { color: var(--gold); border-color: var(--gold-dark); }

/* ── Loading ── */
.loading {
  text-align: center;
  padding: 30px;
  font-size: 9px;
  color: var(--text-dim);
  animation: blink 1s steps(2) infinite;
}
@keyframes blink { 50% { opacity: 0; } }

/* ══════════════════════════════════════
   RESPONSIVE — Collapse to single column
   ══════════════════════════════════════ */
@media (max-width: 1024px) {
  .dashboard {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto auto;
    grid-template-areas:
      "top"
      "center"
      "left"
      "right";
    height: auto;
    overflow: auto;
  }
  body { overflow: auto; }
  .panel-left, .panel-right {
    border: none;
    border-top: 2px solid var(--border);
  }
  .center-scene {
    max-height: 60vh;
  }
  .top-bar { flex-wrap: wrap; }
  .top-bar-stats { flex-wrap: wrap; }
}
@media (max-width: 640px) {
  .top-bar-title { font-size: 8px; }
  .top-stat { padding: 3px 6px; }
  .top-stat-value { font-size: 9px; }
  .speech-bubble { font-size: 4px; max-width: 180px; }
}
</style>
</head>
<body>

<div class="dashboard">
  <!-- ── Top Bar ── -->
  <div class="top-bar">
    <span class="top-bar-title" id="main-title">AGENT OFFICE</span>
    <div class="live-badge offline" id="live-badge">
      <div class="live-dot"></div>
      <span id="live-label">OFFLINE</span>
    </div>
  </div>

  <!-- ── Left Panel ── -->
  <div class="panel-left">
    <div class="panel-section" id="pipeline-section">
      <h3>PIPELINE</h3>
      <div id="pipeline-content"></div>
    </div>
    <div class="panel-section" id="queues-section">
      <h3>QUEUES</h3>
      <div id="queues-content"></div>
    </div>
    <div class="panel-section" id="now-section">
      <h3>NOW PROCESSING</h3>
      <div id="now-content"></div>
    </div>
    <div class="panel-section" id="inbox-section" style="flex:1;display:flex;flex-direction:column;min-height:0">
      <h3>EDITOR INBOX</h3>
      <div class="inbox-scroll" id="inbox-content"></div>
      <div class="inbox-input-wrap">
        <input type="text" class="inbox-input" id="inbox-input" placeholder="Message the Editor...">
        <button class="inbox-send" id="inbox-send">SEND</button>
      </div>
    </div>
  </div>

  <!-- ── Center — Office Scene ── -->
  <div class="center-scene">
    <div class="office-scene-wrapper">
      <!-- Stats overlay (over brick wall) -->
      <div class="scene-stats-overlay" id="top-stats"></div>
      <div class="office-scene" id="office-scene">
        <!-- Layer 0: Room background -->
        <img class="layer-bg" id="room-bg" src="bg-office-clear-new.png"
             onerror="this.style.display='none'">
        <!-- CSS fallback floor (hidden when bg loads) -->
        <div class="office-floor" id="fallback-floor">
          <div class="corridor"></div>
          <div class="door"></div>
        </div>
      </div>

      <!-- Layer 1: Chalkboard task boards (back wall) -->
      <div class="overlay-layer" id="chalkboard-layer">
        <div class="chalkboard chalkboard-left" id="chalkboard-left">
          <div class="chalk-title">EDITOR'S BOARD</div>
          <div class="chalk-list" id="chalk-editor-board"></div>
        </div>
        <div class="chalkboard chalkboard-right" id="chalkboard-right">
          <div class="chalk-title">COMPLETED / FAILED</div>
          <div class="chalk-list" id="chalk-results"></div>
        </div>
      </div>

      <!-- Layer 2: Mid-row desks (Scout, Courier) -->
      <div class="overlay-layer" id="desks-mid-layer">
        <img class="desk-overlay" data-desk="scout" src="scout_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="courier" src="courier_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 3: Mid-row agent sprites (Scout, Courier) -->
      <div class="overlay-layer" id="agents-mid-layer"></div>

      <!-- Layer 4: Front-row desks (Reader, Detective) -->
      <div class="overlay-layer" id="desks-front-layer">
        <img class="desk-overlay" data-desk="reader" src="reader_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="detective" src="detective_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 5: Front-row agent sprites (Reader, Detective) -->
      <div class="overlay-layer" id="agents-front-layer"></div>

      <!-- Layer 6: Editor (roams the aisle freely) -->
      <div class="overlay-layer" id="editor-layer"></div>

      <!-- Layer 7: Bottom-row desks (Designer + Researcher) -->
      <div class="overlay-layer" id="desks-bottom-layer">
        <img class="desk-overlay" data-desk="researcher" src="researcher_desk_trans.png"
             onerror="this.style.display='none'">
        <img class="desk-overlay" data-desk="designer" src="designer_desk_trans.png"
             onerror="this.style.display='none'">
      </div>

      <!-- Layer 8: Bottom-row agent (Designer — highest z-index) -->
      <div class="overlay-layer" id="agents-bottom-layer"></div>

      <!-- Layer 9: UI (speech bubbles + nametags) -->
      <div class="overlay-layer" id="ui-layer"></div>
    </div>
  </div>

  <!-- ── Right Panel ── -->
  <div class="panel-right">
    <div class="panel-section" id="log-section">
      <h3>ACTIVITY LOG</h3>
      <div class="log-filters" id="log-filters"></div>
      <div class="log-scroll" id="log-scroll">
        <div id="log-entries"></div>
      </div>
    </div>
    <div class="panel-section" id="finds-section">
      <h3>NOTABLE FINDS</h3>
      <div id="finds-content"></div>
    </div>
    <div class="panel-section" id="throughput-section">
      <h3>THROUGHPUT</h3>
      <div id="throughput-content"></div>
    </div>
    <div class="panel-section" id="cost-section">
      <h3>EDITOR COST</h3>
      <div id="cost-content"></div>
    </div>
    <div class="panel-section" id="quality-section">
      <h3>DATA QUALITY</h3>
      <div id="quality-content"></div>
    </div>
    <div class="panel-section" id="coverage-section">
      <h3>DISCOVERY MAP</h3>
      <div id="coverage-content"></div>
    </div>
  </div>
</div>

<!-- Agent Controls Popup (shared, positioned at cursor) -->
<div class="agent-controls-popup" id="agent-controls-popup">
  <button class="agent-ctrl-btn pause-btn" id="ctrl-pause">PAUSE</button>
  <button class="agent-ctrl-btn resume-btn" id="ctrl-resume" style="display:none">RESUME</button>
  <button class="agent-ctrl-btn skills-btn" id="ctrl-skills">SKILLS</button>
</div>

<!-- Skills Modal -->
<div class="modal-overlay" id="skills-modal">
  <div class="modal">
    <div class="modal-header">
      <span class="modal-title">AGENT SKILLS</span>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="modal-close" id="skills-edit-btn" style="color:var(--gold);border-color:var(--gold-dark)">EDIT</button>
        <button class="modal-close" id="skills-save-btn" style="display:none;color:#27ae60;border-color:#27ae60">SAVE</button>
        <button class="modal-close" id="skills-cancel-btn" style="display:none">CANCEL</button>
        <button class="modal-close" id="skills-modal-close">X</button>
      </div>
    </div>
    <div class="modal-tabs" id="skills-tabs"></div>
    <div class="modal-body">
      <pre id="skills-content">Select an agent to view their skills...</pre>
      <textarea id="skills-editor" style="display:none;width:100%;height:100%;min-height:400px;font-family:'Press Start 2P',monospace;font-size:7px;line-height:2;color:var(--text);background:rgba(0,0,0,0.3);border:1px solid var(--border-subtle);padding:12px;resize:none;outline:none"></textarea>
    </div>
    <div id="skills-save-status" style="display:none;padding:8px 16px;font-size:7px;border-top:1px solid var(--border-subtle)"></div>
  </div>
</div>

<div class="toast-container" id="toast-container"></div>
<button class="sound-toggle" id="sound-toggle" title="Toggle ambient sound">SFX OFF</button>

<script>
// ── Toast Notifications ──
function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('visible'));
  setTimeout(() => {
    toast.classList.remove('visible');
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// ── Configuration ──
const params = new URLSearchParams(window.location.search);
const STATUS_URL = params.get('status') || 'status.json';
const POLL_MS = parseInt(params.get('poll') || '2000', 10);
const FORCE_DEMO = params.get('demo') === 'true';

// ── Character Names ──
// Each agent has a personality name from their skills file
const AGENT_NAMES = {
  editor:     'Miranda',
  scout:      'Arthur',
  courier:    'Casey',
  reader:     'Elias',
  detective:  'Silas',
  researcher: 'Elena',
  designer:   'Sable',
};

// ── Agent Config ──
const AGENT_CONFIG = {
  editor: {
    homeX: 50, homeY: 78, exitX: 50,
    charHeight: 14,
    color: '#f5c842',
    row: 'editor',
  },
  designer: {
    homeX: 78, homeY: 88, exitX: 56,
    charHeight: 15.12,
    color: '#e91e63',
    row: 'bottom',
  },
  scout: {
    homeX: 22, homeY: 52, exitX: 44,
    charHeight: 14,
    color: '#e74c3c',
    row: 'mid',
  },
  courier: {
    homeX: 76, homeY: 52, exitX: 56,
    charHeight: 14,
    color: '#3498db',
    row: 'mid',
  },
  reader: {
    homeX: 22, homeY: 70, exitX: 44,
    charHeight: 14,
    color: '#2ecc71',
    row: 'front',
  },
  detective: {
    homeX: 78, homeY: 70, exitX: 56,
    charHeight: 14,
    color: '#9b59b6',
    row: 'front',
  },
  researcher: {
    homeX: 22, homeY: 88, exitX: 44,
    charHeight: 17.96,
    color: '#e67e22',
    row: 'bottom',
  },
};
const CORRIDOR_MEET_Y = 55;
// Chalkboard positions (where Editor stands when visiting boards)
const BOARD_LEFT_POS = { x: 20, y: 32 };   // Editor's Board (left chalkboard)
const BOARD_RIGHT_POS = { x: 80, y: 32 };  // Completed/Failed Board (right chalkboard)

// ── State ──
let currentState = null;
let previousState = null;
let agentCharElements = {};
let agentUIElements = {};
let imagesLoaded = { bg: false, chars: {} };
let activeCollaborations = [];
let typewriterTimers = {};
let audioCtx = null;
let soundOn = false;
let ambientOsc = null;
let activeLogFilter = 'All';
let agentWaitCycles = {};     // Per-agent counter of consecutive waiting poll cycles
let agentBoredThreshold = {}; // Per-agent randomized threshold before going bored
let editorBusy = false;
let editorBehaviorTimer = null;
let dataSource = 'demo'; // 'live', 'demo', 'offline'
let lastDataTimestamp = null;
let pendingHumanMessages = []; // Optimistic messages not yet in server data

// ── Image Asset Paths ──
const ASSETS = {
  bg: 'bg-office-clear-new.png',
  chars: {
    editor:    { front: 'editor_front_trans.png', back: 'editor_back_trans.png',
                  blink: 'editor_front_blink_trans.png', tap: 'editor_front_tap_trans.png',
                  watch: 'editor_front_watch_trans.png',
                  listen: 'editor_front_listening_trans.png', happy: 'editor_front_happy_trans.png',
                  failure: 'editor_front_failure_trans.png', clipboard: 'editor_back_clipboard_trans.png',
                  studying: 'editor_front_studying_trans.png' },
    designer:  { front: 'designer_front_trans.png',  back: 'designer_back_trans.png',  waiting: 'designer_front_waiting_trans.png' },
    scout:     { front: 'scout_front_trans.png',     back: 'scout_back_trans.png',     waiting: 'scout_front_waiting_trans.png', done: 'scout_front_done_trans.png' },
    courier:   { front: 'courier_front_trans.png',   back: 'courier_back_trans.png',   waiting: 'courier_front_waiting_trans.png', done: 'courier_front_done_trans.png' },
    reader:    { front: 'reader_front_trans.png',    back: 'reader_back_trans.png',    waiting: 'reader_front_waiting_trans.png' },
    detective: { front: 'detective_front_trans.png',  back: 'detective_back_trans.png', waiting: 'detective_front_waiting_trans.png' },
    researcher: { front: 'researcher_front_trans.png', back: 'researcher_back_trans.png', waiting: 'researcher_front_waiting_trans.png' },
  },
};

// ── Initialize ──
function init() {
  initAgents();
  initDeskLabels();
  initBackground();
  initLogFilters();
  initEditorBehavior();
  initSkillsModal();
  initAgentControlsPopup();
  fetchStatus();
  setInterval(fetchStatus, POLL_MS);
  document.getElementById('sound-toggle').addEventListener('click', toggleSound);
  document.getElementById('inbox-send').addEventListener('click', sendInboxMessage);
  document.getElementById('inbox-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') sendInboxMessage();
  });
  // Track user scroll in inbox to avoid forced auto-scroll to top
  const inboxScroll = document.querySelector('.inbox-scroll') || document.getElementById('inbox-content');
  if (inboxScroll) {
    inboxScroll.addEventListener('scroll', function() {
      // User has scrolled away from top (reading older messages)
      this._userScrolled = this.scrollTop > 80;
    });
  }
}

function initBackground() {
  const bg = document.getElementById('room-bg');
  bg.onload = () => {
    imagesLoaded.bg = true;
    document.getElementById('fallback-floor').style.display = 'none';
  };
  bg.onerror = () => {
    bg.style.display = 'none';
  };
}

function initAgents() {
  const charsMidLayer = document.getElementById('agents-mid-layer');
  const charsFrontLayer = document.getElementById('agents-front-layer');
  const editorLayer = document.getElementById('editor-layer');
  const charsBottomLayer = document.getElementById('agents-bottom-layer');
  const uiLayer = document.getElementById('ui-layer');

  const ROW_LAYERS = {
    mid: charsMidLayer,
    front: charsFrontLayer,
    editor: editorLayer,
    bottom: charsBottomLayer,
  };

  for (const [id, cfg] of Object.entries(AGENT_CONFIG)) {
    // ── Character element ──
    const charEl = document.createElement('div');
    charEl.className = 'agent-char anim-idle';
    charEl.dataset.agent = id;
    charEl.style.left = cfg.homeX + '%';
    charEl.style.top = cfg.homeY + '%';
    charEl.style.height = cfg.charHeight + '%';
    charEl.style.transform = 'translate(-50%, -50%)';

    const backImg = document.createElement('img');
    backImg.className = 'char-img char-back';
    backImg.src = ASSETS.chars[id].back;
    backImg.alt = '';
    backImg.draggable = false;
    backImg.onerror = () => { backImg.style.display = 'none'; };
    charEl.appendChild(backImg);

    const frontImg = document.createElement('img');
    frontImg.className = 'char-img char-front';
    frontImg.src = ASSETS.chars[id].front;
    frontImg.alt = '';
    frontImg.draggable = false;
    frontImg.onerror = () => { frontImg.style.display = 'none'; };
    charEl.appendChild(frontImg);

    // Waiting/bored sprite (all worker agents)
    if (ASSETS.chars[id].waiting) {
      const waitImg = document.createElement('img');
      waitImg.className = 'char-img char-waiting';
      waitImg.src = ASSETS.chars[id].waiting;
      waitImg.alt = '';
      waitImg.draggable = false;
      waitImg.onerror = () => { waitImg.style.display = 'none'; };
      charEl.appendChild(waitImg);
    }

    // Done/relaxing sprite (agents that have completed their work)
    if (ASSETS.chars[id].done) {
      const doneImg = document.createElement('img');
      doneImg.className = 'char-img char-done';
      doneImg.src = ASSETS.chars[id].done;
      doneImg.alt = '';
      doneImg.draggable = false;
      doneImg.onerror = () => { doneImg.style.display = 'none'; };
      charEl.appendChild(doneImg);
    }

    // Editor gets extra pose sprites
    if (id === 'editor') {
      const extras = ASSETS.chars.editor;
      for (const [pose, src] of [['blink', extras.blink], ['tap', extras.tap], ['watch', extras.watch], ['listen', extras.listen], ['happy', extras.happy], ['failure', extras.failure], ['clipboard', extras.clipboard], ['studying', extras.studying]]) {
        const img = document.createElement('img');
        img.className = `char-img char-${pose}`;
        img.src = src;
        img.alt = '';
        img.draggable = false;
        img.onerror = () => { img.style.display = 'none'; };
        charEl.appendChild(img);
      }
      // Editor starts facing front (toward camera)
      charEl.classList.add('show-front');
    }

    const particles = document.createElement('div');
    particles.className = 'particle-container';
    particles.innerHTML = '<div class="particle"></div><div class="particle"></div><div class="particle"></div>';
    charEl.appendChild(particles);

    // Right-click agent to show controls popup
    charEl.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showAgentControlsPopup(id, e.clientX, e.clientY);
    });

    // Place agent in correct row layer
    const targetLayer = ROW_LAYERS[cfg.row] || charsBackLayer;
    targetLayer.appendChild(charEl);
    agentCharElements[id] = charEl;

    // ── UI element (Layer 4) ──
    const uiEl = document.createElement('div');
    uiEl.className = 'agent-ui';
    uiEl.dataset.agent = id;
    uiEl.style.left = cfg.homeX + '%';
    uiEl.style.top = cfg.homeY + '%';
    uiEl.style.height = cfg.charHeight + '%';
    uiEl.style.transform = 'translate(-50%, -50%)';
    uiEl.style.transition = 'left 1.5s ease-in-out, top 1.5s ease-in-out';

    const bubble = document.createElement('div');
    bubble.className = 'speech-bubble';
    bubble.id = `bubble-${id}`;
    uiEl.appendChild(bubble);

    // Only Editor gets a nametag that follows her (no desk)
    if (id === 'editor') {
      const tag = document.createElement('div');
      tag.className = 'agent-nametag';
      tag.style.color = cfg.color;
      tag.style.borderColor = cfg.color;
      tag.textContent = (AGENT_NAMES[id] || id).toUpperCase();
      tag.id = `tag-${id}`;
      uiEl.appendChild(tag);
    }

    const dot = document.createElement('div');
    dot.className = 'status-dot idle';
    dot.id = `dot-${id}`;
    uiEl.appendChild(dot);

    uiLayer.appendChild(uiEl);
    agentUIElements[id] = uiEl;

    charEl.addEventListener('click', () => {
      const b = document.getElementById(`bubble-${id}`);
      if (b) b.classList.toggle('visible');
    });
  }
}

// ── Desk Labels (fixed workstation nametags) ──
function initDeskLabels() {
  const uiLayer = document.getElementById('ui-layer');

  // Labels sit 5px outside the nearest desk edge, vertically centered on desk.
  // Left desks (Scout, Reader) have left edge at 10%; label right-edge → calc(10% - 5px)
  // Right desks (Courier, Detective, Designer) have right edge at 90%; label left-edge → calc(90% + 5px)
  const labels = {
    scout:     { side: 'left',  y: '49%' },
    reader:    { side: 'left',  y: '66.2%' },
    courier:   { side: 'right', y: '48.7%' },
    detective: { side: 'right', y: '67%' },
    designer:   { side: 'right', y: '85.5%' },
    researcher: { side: 'left',  y: '85.5%' },
  };

  for (const [id, pos] of Object.entries(labels)) {
    const cfg = AGENT_CONFIG[id];
    const tag = document.createElement('div');
    tag.className = 'agent-nametag desk-label';
    tag.id = `tag-${id}`;
    tag.style.position = 'absolute';
    tag.style.top = pos.y;
    tag.style.whiteSpace = 'nowrap';
    if (pos.side === 'left') {
      // Anchor label's right edge 5px left of desk's left edge (10%)
      tag.style.left = 'calc(10% - 5px)';
      tag.style.transform = 'translate(-100%, -50%)';
    } else {
      // Anchor label's left edge 5px right of desk's right edge (90%)
      tag.style.left = 'calc(90% + 5px)';
      tag.style.transform = 'translateY(-50%)';
    }
    tag.style.color = cfg.color;
    tag.style.borderColor = cfg.color;
    tag.textContent = (AGENT_NAMES[id] || id).toUpperCase();
    tag.style.pointerEvents = 'none';
    uiLayer.appendChild(tag);
  }
}

// ── Log Filter Buttons ──
function initLogFilters() {
  const container = document.getElementById('log-filters');
  const filters = ['All', 'Miranda', 'Arthur', 'Casey', 'Elias', 'Silas', 'Elena', 'Sable'];
  filters.forEach(f => {
    const btn = document.createElement('button');
    btn.className = 'log-filter-btn' + (f === 'All' ? ' active' : '');
    btn.textContent = f;
    btn.addEventListener('click', () => {
      activeLogFilter = f;
      container.querySelectorAll('.log-filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderLogFiltered();
    });
    container.appendChild(btn);
  });
}

// ── Update Agent Visuals ──
function updateAgent(agentData) {
  const charEl = agentCharElements[agentData.id];
  const uiEl = agentUIElements[agentData.id];
  if (!charEl || !uiEl) return;

  const status = agentData.status || 'idle';

  // Error visibility — show error badge + tooltip on sprite
  if (agentData.errors > 0 && agentData.last_error) {
    charEl.classList.add('has-error');
    charEl.setAttribute('data-error', agentData.last_error);
  } else {
    charEl.classList.remove('has-error');
    charEl.removeAttribute('data-error');
  }

  // Paused visual
  if (agentData.paused) {
    charEl.classList.add('is-paused');
  } else {
    charEl.classList.remove('is-paused');
  }

  // Editor has custom behavior — only update bubble, dot & editor state
  if (agentData.id === 'editor') {
    const dot = document.getElementById('dot-editor');
    if (dot) dot.className = 'status-dot ' + status;
    const tag = document.getElementById('tag-editor');
    if (tag) tag.textContent = 'MIRANDA';

    // 1:1 editor state → sprite mapping
    const editorState = agentData.editor_state || 'idle';
    if (!editorBusy) {
      switch (editorState) {
        case 'listening':
          editorSetSprite('listen');
          updateSpeechBubble('editor', 'Reading your message...');
          break;
        case 'happy':
          editorSetSprite('happy');
          updateSpeechBubble('editor', 'Got it! Instructions acknowledged.');
          break;
        case 'assessing':
          // Editor studies at desk — behavior loop handles the full studying animation
          if (!editorBusy) {
            editorSetSprite('studying');
            updateSpeechBubble('editor', 'Analyzing pipeline strategy...');
          }
          break;
        case 'monitoring':
          // Stay in current idle pose
          break;
      }
    }

    updateSpeechBubble('editor', agentData.speech || agentData.liveTask || agentData.message || '...');
    return;
  }

  // Hub-and-spoke: Working vs Waiting state
  charEl.className = charEl.className.replace(/\banim-\w+/g, '');
  // Only remove hub states if not in an editor-engage animation
  if (!charEl.classList.contains('editor-engage')) {
    charEl.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done', 'show-front');
  }

  const isWorking = status === 'working' && agentData.liveTask;
  const isError = status === 'error';
  const aid = agentData.id;
  // Personality speech takes priority over generic status messages
  const speechText = agentData.speech || agentData.liveTask || agentData.message;

  if (charEl.classList.contains('editor-engage')) {
    // During Editor engagement, keep front-facing + yellow glow, just update animation
    charEl.classList.add('anim-idle');
  } else if (isWorking) {
    // Working: face away (back view), pulsing colored outline
    charEl.classList.add('hub-working', 'anim-working');
    charEl.style.setProperty('--agent-color', AGENT_CONFIG[aid]?.color || '#888');
    updateSpeechBubble(aid, speechText);
    // Reset wait counter — agent is active
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else if (isError) {
    // Error: face camera, shake animation
    charEl.classList.add('show-front', 'anim-error');
    updateSpeechBubble(aid, agentData.speech || agentData.last_error || 'Error!');
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else if (status === 'done' && ASSETS.chars[aid]?.done) {
    // Done with a done sprite: show relaxing pose
    charEl.classList.add('hub-done', 'anim-done');
    updateSpeechBubble(aid, agentData.speech || agentData.message || '');
    agentWaitCycles[aid] = 0;
    delete agentBoredThreshold[aid];
  } else {
    // Waiting/Idle/Done (no done sprite): increment wait counter
    agentWaitCycles[aid] = (agentWaitCycles[aid] || 0) + 1;
    // Randomized threshold per agent (3-6 cycles = 15-30s) — set once per wait period
    if (!agentBoredThreshold[aid]) {
      agentBoredThreshold[aid] = 3 + Math.floor(Math.random() * 4);
    }

    const cycles = agentWaitCycles[aid];
    const threshold = agentBoredThreshold[aid];
    // Use last personality speech — agents generate their own idle chatter
    const waitText = agentData.speech || '';

    if (cycles >= threshold) {
      // Alternate between front and bored every 2-3 cycles
      const togglePeriod = 2 + (threshold % 2); // varies per agent
      const showBored = Math.floor((cycles - threshold) / togglePeriod) % 2 === 0;
      if (showBored) {
        // Bored: show waiting/bored sprite
        charEl.classList.add('hub-bored', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      } else {
        // Brief return to front before going bored again
        charEl.classList.add('hub-waiting', 'show-front', 'anim-idle');
        updateSpeechBubble(aid, waitText);
      }
    } else {
      // Not yet bored: normal front-facing wait
      charEl.classList.add('hub-waiting', 'show-front', 'anim-idle');
      updateSpeechBubble(aid, waitText);
    }
    // Keep waiting bubble persistently visible (override auto-hide)
    const waitBubble = document.getElementById(`bubble-${aid}`);
    if (waitBubble) waitBubble.classList.add('visible');
  }

  const dot = document.getElementById(`dot-${agentData.id}`);
  if (dot) dot.className = 'status-dot ' + status;

  const tag = document.getElementById(`tag-${agentData.id}`);
  if (tag) {
    // Build nametag with cycle count + progress — use character name
    let label = (AGENT_NAMES[agentData.id] || agentData.name || agentData.id).toUpperCase();
    let statsHtml = '';
    const parts = [];
    if (agentData.cycles > 0) parts.push(`${agentData.cycles} cycles`);
    const p = agentData.progress;
    if (p && p.total > 0) parts.push(`${p.current}/${p.total}`);
    if (parts.length) statsHtml = `<span class="tag-stats">${parts.join(' · ')}</span>`;
    tag.innerHTML = label + statsHtml;
  }
}

// ── Speech Bubble Typewriter ──
function updateSpeechBubble(agentId, text) {
  const bubble = document.getElementById(`bubble-${agentId}`);
  if (!bubble) return;
  if (bubble.dataset.fullText === text) return;
  bubble.dataset.fullText = text;

  if (typewriterTimers[agentId]) {
    clearInterval(typewriterTimers[agentId]);
    typewriterTimers[agentId] = null;
  }

  bubble.classList.add('visible');
  bubble.textContent = '';

  let i = 0;
  typewriterTimers[agentId] = setInterval(() => {
    if (i < text.length) {
      bubble.textContent = text.substring(0, i + 1);
      i++;
    } else {
      clearInterval(typewriterTimers[agentId]);
      typewriterTimers[agentId] = null;
      const displayTime = Math.max(8000, text.length * 80);
      setTimeout(() => {
        if (bubble.dataset.fullText === text) {
          bubble.classList.remove('visible');
        }
      }, displayTime);
    }
  }, 35);
}

// ── Agent Movement ──
function moveAgentTo(agentId, xPct, yPct, showFront = false) {
  const charEl = agentCharElements[agentId];
  const uiEl = agentUIElements[agentId];
  if (!charEl || !uiEl) return;

  if (showFront) {
    charEl.classList.add('show-front');
  } else {
    charEl.classList.remove('show-front');
  }

  charEl.style.left = xPct + '%';
  charEl.style.top = yPct + '%';
  uiEl.style.left = xPct + '%';
  uiEl.style.top = yPct + '%';
}

// ── Editor Aisle Pathfinding ──
// Routes the Editor along aisles — never diagonally through desks.
// Rule: to change rows, first go to center aisle (x=50), walk vertically, then walk to destination X.
const AISLE_X = 50;
const EDITOR_WALK_SPEED = 35; // percent-units per second

async function walkEditorTo(destX, destY, options = {}) {
  // options.finalSprite — sprite to show when done (e.g. 'front', 'back', 'clipboard')
  // options.carrySprite — sprite override during all walk segments (e.g. 'clipboard')
  const charEl = agentCharElements['editor'];
  const uiEl = agentUIElements['editor'];
  if (!charEl || !uiEl) return;

  const curX = parseFloat(charEl.style.left) || AGENT_CONFIG.editor.homeX;
  const curY = parseFloat(charEl.style.top) || AGENT_CONFIG.editor.homeY;

  // Build waypoints
  const waypoints = [];
  const isOnAisle = Math.abs(curX - AISLE_X) < 3;
  const destIsOnAisle = Math.abs(destX - AISLE_X) < 3;
  const sameRow = Math.abs(curY - destY) < 3;

  if (sameRow) {
    // Same row — walk horizontally
    waypoints.push({ x: destX, y: curY });
  } else {
    // Different row — route through center aisle
    if (!isOnAisle) {
      waypoints.push({ x: AISLE_X, y: curY }); // Step to aisle
    }
    waypoints.push({ x: AISLE_X, y: destY }); // Walk aisle vertically
    if (!destIsOnAisle) {
      waypoints.push({ x: destX, y: destY }); // Walk to final X
    }
  }

  // Walk each segment
  let prevX = curX, prevY = curY;
  for (const wp of waypoints) {
    const dx = wp.x - prevX;
    const dy = wp.y - prevY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) { prevX = wp.x; prevY = wp.y; continue; }

    const duration = Math.max(0.4, Math.min(2.0, dist / EDITOR_WALK_SPEED));

    // Set walk sprite
    if (options.carrySprite) {
      editorSetSprite(options.carrySprite);
    } else if (Math.abs(dy) >= Math.abs(dx)) {
      editorSetSprite(dy < 0 ? 'back' : 'front');
    }
    // For horizontal moves with no carrySprite, keep current sprite

    // Set transition speed proportional to distance
    const trans = `left ${duration}s ease-in-out, top ${duration}s ease-in-out`;
    charEl.style.transition = trans;
    uiEl.style.transition = trans;

    charEl.style.left = wp.x + '%';
    charEl.style.top = wp.y + '%';
    uiEl.style.left = wp.x + '%';
    uiEl.style.top = wp.y + '%';

    await sleep(duration * 1000 + 50);
    prevX = wp.x;
    prevY = wp.y;
  }

  // Reset to default CSS transition
  charEl.style.transition = '';
  uiEl.style.transition = '';

  if (options.finalSprite) editorSetSprite(options.finalSprite);
}

function moveAgentHome(agentId) {
  const cfg = AGENT_CONFIG[agentId];
  if (cfg) moveAgentTo(agentId, cfg.homeX, cfg.homeY, false);
}

// ── Collaboration System (Hub-and-Spoke: Editor mediates all exchanges) ──
function triggerCollaboration(fromId, toId, label) {
  // In hub-and-spoke model, all collaborations route through Editor
  // If neither party is the editor, Editor visits both sequentially
  if (fromId !== 'editor' && toId !== 'editor') {
    editorMeeting(fromId, label);
    setTimeout(() => editorMeeting(toId, label), 7000);
    return;
  }

  // One party is the editor — do a direct Editor↔Agent meeting
  const agentId = fromId === 'editor' ? toId : fromId;
  editorMeeting(agentId, label);
}

/** Editor walks to agent's row, both glow yellow, exchange info, return. */
async function editorMeeting(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;

  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Yellow glow on both Editor and target agent
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }

  // Agent steps toward the aisle
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Editor walks toward agent's row in center aisle
  const goingUp = target.homeY < cfg.homeY;
  editorSetSprite(goingUp ? 'back' : 'front');
  moveAgentTo('editor', 50, target.homeY, !goingUp);
  if (goingUp) editorSetSprite('back');
  await sleep(1800);

  // Face each other and interact
  editorSetSprite('front');
  if (label) {
    updateSpeechBubble('editor', label);
  } else {
    updateSpeechBubble('editor', `Briefing ${agentId}...`);
  }
  await sleep(2500);

  // Clear engagement glow
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');

  // Agent returns to desk
  moveAgentHome(agentId);

  // Editor returns home
  const goingHome = cfg.homeY > target.homeY;
  editorSetSprite(goingHome ? 'front' : 'back');
  moveAgentTo('editor', cfg.homeX, cfg.homeY, goingHome);
  if (!goingHome) editorSetSprite('back');
  await sleep(1800);

  editorSetSprite('front');
  editorBusy = false;
}

function renderCollaborations(collaborations) {
  if (!collaborations || !collaborations.length) return;
  const newCollabs = collaborations.filter(c => {
    const key = `${c.from}-${c.to}-${c.label}`;
    if (activeCollaborations.includes(key)) return false;
    activeCollaborations.push(key);
    if (activeCollaborations.length > 20) activeCollaborations.shift();
    return true;
  });
  if (newCollabs.length > 0) {
    newCollabs.forEach((c, i) => {
      setTimeout(() => triggerCollaboration(c.from, c.to, c.label || ''), i * 5000);
    });
  }
}

// ══════════════════════════════════════
// RENDERING — Top Bar
// ══════════════════════════════════════
function renderTitle(data) {
  document.getElementById('main-title').textContent = 'AGENT OFFICE';
  document.title = 'Agent Office';
}

function renderTopStats(stats) {
  const container = document.getElementById('top-stats');
  if (!stats || !stats.length) {
    container.innerHTML = '';
    return;
  }
  container.innerHTML = stats.map(s => {
    const display = s.total ? `${s.value}/${s.total}` : String(s.value);
    const hasDetails = s.details && s.details.length > 0;
    const cls = hasDetails ? 'top-stat has-details' : 'top-stat';
    const popupType = s.popup_type || 'confirmed';
    return `<div class="${cls}"
      ${hasDetails ? `data-details='${JSON.stringify(s.details).replace(/'/g, "&#39;")}'` : ''}
      ${hasDetails ? `data-popup-type="${popupType}"` : ''}>
      <span class="top-stat-value">${escHtml(display)}</span>
      <span class="top-stat-label">${escHtml(s.label)}</span>
    </div>`;
  }).join('');

  // Attach right-click handler to stats with details
  container.querySelectorAll('.has-details').forEach(el => {
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const details = JSON.parse(el.dataset.details);
      const popupType = el.dataset.popupType || 'confirmed';
      showStatPopup(e, details, popupType);
    });
  });
}

/** Show a popup with stat details near the cursor. Dispatches by popupType. */
function showStatPopup(event, details, popupType) {
  // Remove any existing popup
  const old = document.getElementById('stat-popup');
  if (old) old.remove();

  const popup = document.createElement('div');
  popup.id = 'stat-popup';
  popup.style.cssText = `
    position: fixed; z-index: 9999;
    left: ${event.clientX + 4}px; top: ${event.clientY + 4}px;
    background: #1a0e2e; border: 2px solid var(--gold);
    padding: 12px 16px; min-width: 240px; max-width: 420px;
    max-height: 400px; overflow-y: auto;
    font-family: 'Press Start 2P', monospace;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  `;

  let html = '';
  if (popupType === 'memories') {
    html = renderMemoriesPopup(details);
  } else if (popupType === 'dossiers') {
    html = renderDossiersPopup(details);
  } else {
    html = renderConfirmedPopup(details);
  }

  popup.innerHTML = html;
  document.body.appendChild(popup);

  // Close on any click
  const close = () => { popup.remove(); document.removeEventListener('click', close); };
  setTimeout(() => document.addEventListener('click', close), 100);
}

function renderConfirmedPopup(details) {
  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">CONFIRMED ASSOCIATES</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">None yet</div>';
  } else {
    for (const d of details) {
      const color = d.strength === 'high' ? '#e74c3c' : '#e67e22';
      html += `<div style="margin-bottom:8px; padding:6px 8px; border-left:3px solid ${color}; background:rgba(255,255,255,0.03);">
        <div style="font-size:9px; color:var(--text);">${escHtml(d.name)}</div>
        <div style="font-size:7px; color:${color}; margin-top:3px; text-transform:uppercase;">${escHtml(d.strength)} connection</div>
        <div style="font-size:7px; color:var(--text-dim); margin-top:3px; line-height:1.5;">${escHtml(d.rationale || '')}</div>
      </div>`;
    }
  }
  return html;
}

function renderMemoriesPopup(details) {
  const agentColors = {
    scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71',
    detective: '#9b59b6', researcher: '#e67e22', editor: '#f5c842', designer: '#e91e63',
  };
  const outcomeColors = { success: '#2ecc71', failure: '#e74c3c', decision: '#3498db', observation: '#888' };

  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">AGENT MEMORIES</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">No memories yet</div>';
  } else {
    for (const m of details) {
      const ac = agentColors[m.agent] || '#888';
      const oc = outcomeColors[m.outcome] || '#888';
      html += `<div style="margin-bottom:6px; padding:5px 7px; border-left:2px solid ${ac}; background:rgba(255,255,255,0.02);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:3px;">
          <span style="font-size:6px; color:${ac}; text-transform:uppercase;">${escHtml(m.agent)}</span>
          <span style="font-size:5px; color:var(--text-muted);">${escHtml(m.time)}</span>
        </div>
        <div style="font-size:7px; color:var(--text-dim); line-height:1.5;">${escHtml(m.text)}</div>
        <span style="font-size:5px; color:${oc}; text-transform:uppercase; letter-spacing:0.3px;">${escHtml(m.outcome)}</span>
      </div>`;
    }
  }
  return html;
}

function renderDossiersPopup(details) {
  const strengthColors = { high: '#e74c3c', medium: '#e67e22', low: '#f1c40f', coincidence: '#888', unknown: '#555' };

  let html = '<div style="font-size:8px; color:var(--gold); margin-bottom:10px; letter-spacing:1px;">ALL DOSSIERS</div>';
  if (!details || details.length === 0) {
    html += '<div style="font-size:8px; color:var(--text-dim);">No dossiers yet</div>';
  } else {
    for (const d of details) {
      const sc = strengthColors[d.strength] || '#888';
      const verdictColor = d.editor_verdict === 'CONFIRMED' ? '#2ecc71'
        : d.editor_verdict === 'REJECTED' ? '#e74c3c' : '';
      html += `<div style="margin-bottom:8px; padding:6px 8px; border-left:3px solid ${sc}; background:rgba(255,255,255,0.03);">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <span style="font-size:9px; color:var(--text);">${escHtml(d.name)}</span>
          ${d.editor_verdict ? `<span style="font-size:6px; color:${verdictColor}; letter-spacing:0.5px;">${escHtml(d.editor_verdict)}</span>` : ''}
        </div>
        <div style="font-size:7px; color:${sc}; margin-top:3px; text-transform:uppercase;">${escHtml(d.strength)} connection</div>
        ${d.strength_rationale ? `<div style="font-size:6px; color:var(--text-dim); margin-top:3px; line-height:1.5;">${escHtml(d.strength_rationale)}</div>` : ''}
        ${d.editor_reasoning ? `<div style="font-size:6px; color:${verdictColor}; margin-top:3px; line-height:1.5; opacity:0.8;">${escHtml(d.editor_reasoning)}</div>` : ''}
      </div>`;
    }
  }
  return html;
}

// ══════════════════════════════════════
// RENDERING — Left Panel
// ══════════════════════════════════════
function renderPipeline(pipeline) {
  const container = document.getElementById('pipeline-content');
  if (!pipeline || !pipeline.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No data</div>';
    return;
  }
  const maxTotal = Math.max(...pipeline.map(p => p.total || p.count), 1);
  container.innerHTML = pipeline.map(p => {
    const total = p.total || p.count;
    const pct = Math.max(2, (p.count / maxTotal) * 100);
    const label = total > p.count ? `${p.count}/${total}` : `${p.count}`;
    return `<div class="pipeline-row">
      <span class="pipeline-label">${escHtml(p.stage)}</span>
      <div class="pipeline-bar-wrap">
        <div class="pipeline-bar" style="width:${pct}%;background:${p.color}"></div>
      </div>
      <span class="pipeline-count">${label}</span>
    </div>`;
  }).join('');
}

function renderQueueDepths(queues) {
  const container = document.getElementById('queues-content');
  if (!queues || !queues.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No queues</div>';
    return;
  }
  container.innerHTML = queues.map(q =>
    `<div class="queue-row">
      <div class="queue-dot" style="background:${q.color}"></div>
      <span class="queue-count">${q.count}</span>
      <span class="queue-label">${escHtml(q.label)}</span>
    </div>`
  ).join('');
}

function renderInbox(messages) {
  const container = document.getElementById('inbox-content');

  // Merge server messages with pending optimistic messages
  let allMessages = messages ? [...messages] : [];

  // Add any pending human messages not yet reflected in server data
  for (const pm of pendingHumanMessages) {
    const alreadyInServer = allMessages.some(m =>
      m.sender === 'human' && m.text === pm.text && m.time === pm.time
    );
    if (!alreadyInServer) {
      allMessages.unshift(pm); // Show at top (most recent)
    }
  }

  // Clean up pending messages that are now in server data
  pendingHumanMessages = pendingHumanMessages.filter(pm =>
    !allMessages.some(m => m !== pm && m.sender === 'human' && m.text === pm.text && m.time === pm.time)
  );

  if (!allMessages.length) {
    container.innerHTML = '<div class="inbox-empty">No messages yet</div>';
    return;
  }
  container.innerHTML = allMessages.map(m => {
    const isHuman = m.sender === 'human';
    let cls = 'inbox-msg';
    if (isHuman) cls += ' human';
    else if (m.is_reply) cls += ' reply';
    else if (m.type === 'alert') cls += ' alert';
    const opacity = m.pending ? ' style="opacity:0.6"' : '';
    return `<div class="${cls}"${opacity}>
      <div class="inbox-msg-time">${escHtml(m.time || '')}</div>
      <div class="inbox-msg-text">${escHtml(m.text || '')}</div>
    </div>`;
  }).join('');

  // Auto-scroll to top (newest messages are first) unless user has scrolled down
  const scrollParent = container.closest('.inbox-scroll') || container;
  if (!scrollParent._userScrolled || scrollParent.scrollTop < 80) {
    scrollParent.scrollTop = 0;
  }
}

async function sendInboxMessage() {
  const input = document.getElementById('inbox-input');
  const text = input.value.trim();
  if (!text) return;

  const now = new Date();
  const timeStr = now.getHours().toString().padStart(2,'0') + ':' + now.getMinutes().toString().padStart(2,'0');

  // Add to pending messages (survives re-renders)
  const pendingMsg = {
    time: timeStr,
    text: text,
    sender: 'human',
    pending: true,
  };
  pendingHumanMessages.unshift(pendingMsg);

  input.value = '';

  // Re-render inbox with the pending message
  renderInbox(currentState ? currentState.editor_inbox : []);

  try {
    await fetch('/api/inbox', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text }),
    });
    pendingMsg.pending = false;
  } catch (e) {
    console.error('Failed to send message:', e);
    pendingMsg.failed = true;
    showToast('MESSAGE FAILED — server offline?', 'error');
  }
}

function renderNowProcessing(now) {
  const container = document.getElementById('now-content');
  if (!now || Object.keys(now).length === 0) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">Idle</div>';
    return;
  }
  const agentColors = { editor: '#f5c842', scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71', detective: '#9b59b6', researcher: '#e67e22', designer: '#e91e63' };
  container.innerHTML = Object.entries(now).map(([id, info]) => {
    const color = agentColors[id] || '#888';
    const activeClass = info.active ? ' active' : '';
    return `<div class="now-row">
      <div class="now-dot${activeClass}" style="background:${color}"></div>
      <span class="now-agent" style="color:${color}">${AGENT_NAMES[id] || id.charAt(0).toUpperCase() + id.slice(1)}</span>
      <span class="now-task">${escHtml(info.task)}</span>
    </div>`;
  }).join('');
}

// ══════════════════════════════════════
// RENDERING — Right Panel
// ══════════════════════════════════════
let cachedLog = [];

function renderLogWithFilters(log) {
  cachedLog = log || [];
  renderLogFiltered();
}

// Map character names back to role names for log filtering
const CHAR_TO_ROLE = {};
const ROLE_TO_CHAR = {};
for (const [roleId, charName] of Object.entries(AGENT_NAMES)) {
  const roleName = roleId.charAt(0).toUpperCase() + roleId.slice(1);
  CHAR_TO_ROLE[charName] = roleName;
  ROLE_TO_CHAR[roleName] = charName;
}

function renderLogFiltered() {
  const container = document.getElementById('log-entries');
  // activeLogFilter uses character names — map to role names for log data matching
  const roleFilter = CHAR_TO_ROLE[activeLogFilter] || activeLogFilter;
  const filtered = activeLogFilter === 'All'
    ? cachedLog
    : cachedLog.filter(e => e.agent === roleFilter || e.agent === activeLogFilter);

  if (!filtered.length) {
    container.innerHTML = '<div class="log-entry"><span class="log-event">No activity yet...</span></div>';
    return;
  }
  const agentColors = { Editor: '#f5c842', Scout: '#e74c3c', Courier: '#3498db', Reader: '#2ecc71', Detective: '#9b59b6', Researcher: '#e67e22', Designer: '#e91e63' };
  container.innerHTML = filtered.map(entry => {
    const color = agentColors[entry.agent] || 'var(--gold)';
    return `<div class="log-entry">
      <span class="log-time">${escHtml(entry.time || '')}</span>
      <span class="log-agent" style="color:${color}">${escHtml(ROLE_TO_CHAR[entry.agent] || entry.agent || '')}</span>
      <span class="log-event">${escHtml(entry.event || '')}</span>
    </div>`;
  }).join('');
}

const _prevFinds = new Set();
function renderNotableFinds(finds) {
  const container = document.getElementById('finds-content');
  if (!finds || !finds.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No notable finds yet</div>';
    return;
  }
  const currentKeys = new Set(finds.map(f => f.name));
  container.innerHTML = finds.map(f => {
    const typeClass = f.type || '';
    const isNew = !_prevFinds.has(f.name) && _prevFinds.size > 0;
    const meta = [f.issue, f.location].filter(Boolean).join(' \u00B7 ');

    // Build pipeline stages
    const pipeline = buildFindPipeline(f);

    return `<div class="find-card ${typeClass}${isNew ? ' new-find' : ''}">
      <div class="find-name">${escHtml(f.name)}</div>
      ${meta ? `<div class="find-meta">${escHtml(meta)}</div>` : ''}
      <div class="find-pipeline">${pipeline}</div>
    </div>`;
  }).join('');
  // Track for next render — detect new arrivals
  _prevFinds.clear();
  currentKeys.forEach(k => _prevFinds.add(k));
}

/** Build the DET → RES → EDT pipeline HTML for a notable find. */
function buildFindPipeline(f) {
  const status = f.status || '';
  const research = f.research || '';
  const researchDetail = f.research_detail || '';

  // ── DET stage ──
  const detColors = {
    confirmed_match: '#e74c3c',
    likely_match: '#e67e22',
    possible_match: '#f1c40f',
    needs_review: '#3498db',
    pending: '#666',
  };
  const detLabels = {
    confirmed_match: 'CONFIRMED',
    likely_match: 'LIKELY',
    possible_match: 'POSSIBLE',
    needs_review: 'REVIEW',
    pending: 'PENDING',
  };
  const detColor = detColors[status] || '#666';
  const detLabel = detLabels[status] || status.toUpperCase();
  const detComplete = status && status !== 'pending';
  const detDot = detComplete ? 'complete' : '';
  const detHtml = `<span class="pipe-stage" style="color:${detColor}">` +
    `<span class="pipe-stage-label">DET</span>` +
    `<span class="pipe-dot ${detDot}"></span>` +
    `<span class="pipe-verdict">${detLabel}</span>` +
    `</span>`;

  // ── RES stage ──
  const resStarted = research && research !== 'null';
  const resComplete = research === 'dossier_complete';
  const resActive = research === 'investigating';
  const resQueued = research === 'queued';
  let resColor = '#666';
  let resDotClass = '';
  let resLabel = '';
  if (resComplete) {
    const strengthColors = { high: '#e74c3c', medium: '#e67e22', low: '#f1c40f', coincidence: '#888' };
    resColor = strengthColors[researchDetail] || '#2ecc71';
    resDotClass = 'complete';
    resLabel = (researchDetail || 'done').toUpperCase();
  } else if (resActive) {
    resColor = '#e67e22';
    resDotClass = 'active';
    resLabel = 'ACTIVE';
  } else if (resQueued) {
    resColor = '#888';
    resDotClass = '';
    resLabel = 'QUEUED';
  }
  const arrowDet = detComplete ? '' : ' dim';
  const resHtml = `<span class="pipe-arrow${arrowDet}">\u2192</span>` +
    `<span class="pipe-stage" style="color:${resColor}">` +
    `<span class="pipe-stage-label">RES</span>` +
    `<span class="pipe-dot ${resDotClass}"></span>` +
    (resLabel ? `<span class="pipe-verdict">${resLabel}</span>` : '') +
    `</span>`;

  // ── EDT stage ── (only visible when dossier is complete)
  let edtHtml = '';
  if (resComplete) {
    const arrowRes = '';
    const edtReviewed = f.editor_verdict && f.editor_verdict !== '';
    const edtColor = edtReviewed ? '#2ecc71' : '#666';
    const edtDotClass = edtReviewed ? 'complete' : '';
    const edtLabel = edtReviewed ? f.editor_verdict : 'PENDING';
    edtHtml = `<span class="pipe-arrow${arrowRes}">\u2192</span>` +
      `<span class="pipe-stage" style="color:${edtColor}">` +
      `<span class="pipe-stage-label">EDT</span>` +
      `<span class="pipe-dot ${edtDotClass}"></span>` +
      `<span class="pipe-verdict">${edtLabel}</span>` +
      `</span>`;
  }

  return detHtml + resHtml + edtHtml;
}

function renderQuality(quality) {
  const container = document.getElementById('quality-content');
  if (!quality || !quality.fields || !quality.fields.length) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No extraction data</div>';
    return;
  }
  container.innerHTML = quality.fields.map(f =>
    `<div class="quality-row">
      <span class="quality-label">${escHtml(f.label)}</span>
      <div class="quality-bar-wrap">
        <div class="quality-bar" style="width:${f.pct}%"></div>
      </div>
      <span class="quality-pct">${f.pct}%</span>
    </div>`
  ).join('');
}

// ══════════════════════════════════════
// RENDERING — Live Badge
// ══════════════════════════════════════
function updateLiveBadge(timestamp) {
  const badge = document.getElementById('live-badge');
  const label = document.getElementById('live-label');
  if (!badge || !label) return;

  if (!timestamp) {
    badge.className = 'live-badge offline';
    label.textContent = 'OFFLINE';
    dataSource = 'offline';
    return;
  }

  const dataTime = new Date(timestamp).getTime();
  const now = Date.now();
  const ageSeconds = (now - dataTime) / 1000;

  if (ageSeconds < 15) {
    badge.className = 'live-badge live';
    label.textContent = 'LIVE';
    dataSource = 'live';
  } else if (ageSeconds < 120) {
    badge.className = 'live-badge stale';
    label.textContent = `STALE (${Math.round(ageSeconds)}s)`;
    dataSource = 'live'; // Still from live source, just old
  } else {
    badge.className = 'live-badge offline';
    label.textContent = 'OFFLINE';
    dataSource = 'offline';
  }
}

// ══════════════════════════════════════
// RENDERING — Throughput & Cost
// ══════════════════════════════════════
function renderThroughput(throughput) {
  const container = document.getElementById('throughput-content');
  if (!throughput) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No data</div>';
    return;
  }

  let etaText = 'N/A';
  if (throughput.eta_hours !== null && throughput.eta_hours !== undefined) {
    if (throughput.eta_hours < 1) {
      etaText = `${Math.round(throughput.eta_hours * 60)}m`;
    } else {
      etaText = `${throughput.eta_hours}h`;
    }
  }

  container.innerHTML = `
    <div class="metric-row">
      <span class="metric-label">Downloads</span>
      <span class="metric-value">${throughput.downloads_per_hour || 0}/hr</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Extractions</span>
      <span class="metric-value">${throughput.extractions_per_hour || 0}/hr</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">ETA</span>
      <span class="metric-value gold">${etaText}</span>
    </div>
  `;
}

function renderCost(cost) {
  const container = document.getElementById('cost-content');
  if (!cost || !cost.api_calls) {
    container.innerHTML = '<div style="font-size:5px;color:var(--text-dim)">No API calls yet</div>';
    return;
  }

  const totalCost = (cost.total_cost || 0).toFixed(4);
  const inputK = Math.round((cost.input_tokens || 0) / 1000);
  const outputK = Math.round((cost.output_tokens || 0) / 1000);

  container.innerHTML = `
    <div class="metric-row">
      <span class="metric-label">API Calls</span>
      <span class="metric-value">${cost.api_calls}</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Tokens (in/out)</span>
      <span class="metric-value">${inputK}K / ${outputK}K</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Total Cost</span>
      <span class="metric-value gold">$${totalCost}</span>
    </div>
  `;
}

// ══════════════════════════════════════
// RENDERING — Chalkboard Task Board
// ══════════════════════════════════════
const AGENT_COLORS_CHALK = {
  scout: '#e74c3c', courier: '#3498db', reader: '#2ecc71',
  detective: '#9b59b6', researcher: '#e67e22', designer: '#e91e63', editor: '#f5c842'
};

function renderChalkboards(taskBoard, editorLedger) {
  const boardEl = document.getElementById('chalk-editor-board');
  const resultsEl = document.getElementById('chalk-results');
  if (!boardEl || !resultsEl) return;

  // ── Left board: Editor's Board (failures, stuck, exhausted from ledger) ──
  const ledger = editorLedger || {};
  const exhausted = ledger.exhausted || [];
  const stuck = ledger.stuck || [];
  const recentFailures = ledger.recent_failures || [];
  const totalFail = ledger.total_failures || 0;
  const totalOk = ledger.total_successes || 0;

  if (exhausted.length === 0 && stuck.length === 0 && recentFailures.length === 0) {
    // If no ledger data, show in-flight tasks as a fallback
    const inFlight = taskBoard?.in_flight || [];
    if (inFlight.length === 0) {
      boardEl.innerHTML = '<div class="chalk-empty">All clear</div>';
    } else {
      boardEl.innerHTML = inFlight.slice(0, 6).map(task => {
        const agentId = (task.agent || '?').toLowerCase();
        const agent = AGENT_NAMES[agentId] || agentId;
        const goal = task.goal || task.type || '';
        return `<div class="chalk-item in-flight">
          <span class="chalk-agent">${escHtml(agent)}</span>
          <span class="chalk-goal">${escHtml(goal)}</span>
        </div>`;
      }).join('');
    }
  } else {
    let html = '';

    // Summary line
    if (totalFail > 0 || totalOk > 0) {
      html += `<div class="chalk-section-label">${totalOk} ok / ${totalFail} fail</div>`;
    }

    // Exhausted items (gave up — crossed out)
    if (exhausted.length > 0) {
      html += `<div class="chalk-section-label">GAVE UP (${exhausted.length})</div>`;
      html += exhausted.slice(0, 4).map(item => {
        return `<div class="chalk-item exhausted" title="${escHtml(item.last_error)}">
          <span class="chalk-agent">${escHtml(item.key)}</span>
          <span class="chalk-goal">${escHtml(item.last_error)}</span>
          <span class="chalk-count">${item.failures}x</span>
        </div>`;
      }).join('');
    }

    // Stuck items (retrying)
    if (stuck.length > 0) {
      html += `<div class="chalk-section-label">RETRYING (${stuck.length})</div>`;
      html += stuck.slice(0, 4).map(item => {
        return `<div class="chalk-item stuck" title="${escHtml(item.last_error)}">
          <span class="chalk-agent">${escHtml(item.key)}</span>
          <span class="chalk-goal">${escHtml(item.last_error)}</span>
          <span class="chalk-count">${item.failures}x</span>
        </div>`;
      }).join('');
    }

    boardEl.innerHTML = html;
  }

  // ── Right board: Completed + Failed (most recent first, interleaved) ──
  const completed = (taskBoard?.completed || []).map(t => ({ ...t, _status: 'completed' }));
  const failed = (taskBoard?.failed || []).map(t => ({ ...t, _status: 'failed' }));
  const results = [...completed, ...failed].slice(-12).reverse();

  if (results.length === 0) {
    resultsEl.innerHTML = '<div class="chalk-empty">No results yet</div>';
  } else {
    resultsEl.innerHTML = results.map(task => {
      const agentId = (task.agent || task.completed_by || task.failed_by || '?').toLowerCase();
      const agent = AGENT_NAMES[agentId] || agentId;
      const goal = task._status === 'failed'
        ? (task.error || task.goal || task.type || 'Failed')
        : (task.goal || task.type || 'Done');
      const cls = task._status;
      return `<div class="chalk-item ${cls}">
        <span class="chalk-agent">${escHtml(agent)}</span>
        <span class="chalk-goal">${escHtml(goal)}</span>
      </div>`;
    }).join('');
  }
}

// ══════════════════════════════════════
// DISCOVERY COVERAGE MAP
// ══════════════════════════════════════
const MONTH_LABELS = ['J','F','M','A','M','J','J','A','S','O','N','D'];

let coverageMapBuilt = false;

function renderCoverageMap(coverageMap) {
  const el = document.getElementById('coverage-content');
  if (!el || !coverageMap) return;

  // Incremental update: if grid already built, only update changed cells
  if (coverageMapBuilt && previousState && previousState.coverage_map) {
    const prev = previousState.coverage_map;
    for (let y = 1988; y <= 2025; y++) {
      const yk = String(y);
      const yearData = coverageMap[yk] || {};
      const prevYear = prev[yk] || {};
      for (let m = 1; m <= 12; m++) {
        const mk = String(m);
        const newStatus = yearData[mk] || '';
        const oldStatus = prevYear[mk] || '';
        if (newStatus !== oldStatus) {
          const cell = el.querySelector(`[data-y="${y}"][data-m="${m}"]`);
          if (cell) {
            cell.className = `coverage-cell ${newStatus}`;
            cell.title = `${MONTH_LABELS[m-1]} ${y}: ${newStatus || 'missing'}`;
          }
        }
      }
    }
    return;
  }

  // First render: build full grid with data attributes
  let html = '<div class="coverage-grid">';

  html += '<div></div>';
  for (let m = 0; m < 12; m++) {
    html += `<div class="coverage-month-header">${MONTH_LABELS[m]}</div>`;
  }

  for (let y = 1988; y <= 2025; y++) {
    const showLabel = (y % 5 === 0 || y === 1988 || y === 2025);
    html += `<div class="coverage-year-label">${showLabel ? y : ''}</div>`;
    const yearData = coverageMap[String(y)] || {};
    for (let m = 1; m <= 12; m++) {
      const status = yearData[String(m)] || '';
      const title = `${MONTH_LABELS[m-1]} ${y}: ${status || 'missing'}`;
      html += `<div class="coverage-cell ${status}" data-y="${y}" data-m="${m}" title="${title}"></div>`;
    }
  }

  html += '</div>';

  html += `<div class="coverage-legend">
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:var(--scout-color);opacity:0.7"></span>Disc.</div>
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:var(--courier-color);opacity:0.8"></span>Down.</div>
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:var(--reader-color);opacity:0.9"></span>Extr.</div>
    <div class="coverage-legend-item"><span class="coverage-legend-swatch" style="background:rgba(255,255,255,0.04)"></span>Missing</div>
  </div>`;

  el.innerHTML = html;
  coverageMapBuilt = true;
}

// ══════════════════════════════════════
// AGENT CONTROLS — Floating Popup
// ══════════════════════════════════════
let activeControlAgent = null;

function showAgentControlsPopup(agentId, clientX, clientY) {
  const popup = document.getElementById('agent-controls-popup');
  activeControlAgent = agentId;

  // Position at cursor
  popup.style.left = clientX + 'px';
  popup.style.top = clientY + 'px';

  // Set button colors to match the agent
  const cfg = AGENT_CONFIG[agentId];
  if (cfg) popup.style.setProperty('--agent-color', cfg.color);

  popup.classList.add('visible');

  // Show pause or resume based on current agent state
  const agentData = currentState?.agents?.find(a => a.id === agentId);
  const isPaused = agentData?.paused;
  document.getElementById('ctrl-pause').style.display = isPaused ? 'none' : '';
  document.getElementById('ctrl-resume').style.display = isPaused ? '' : 'none';
}

function hideAgentControlsPopup() {
  document.getElementById('agent-controls-popup').classList.remove('visible');
  activeControlAgent = null;
}

function initAgentControlsPopup() {
  document.getElementById('ctrl-pause').addEventListener('click', () => handleAgentControl('pause'));
  document.getElementById('ctrl-resume').addEventListener('click', () => handleAgentControl('resume'));
  document.getElementById('ctrl-skills').addEventListener('click', () => handleAgentControl('skills'));
  // Click anywhere else to dismiss
  document.addEventListener('click', (e) => {
    const popup = document.getElementById('agent-controls-popup');
    if (popup.classList.contains('visible') && !popup.contains(e.target)) {
      hideAgentControlsPopup();
    }
  });
}

async function handleAgentControl(command) {
  const agentId = activeControlAgent;
  if (!agentId) return;
  hideAgentControlsPopup();

  if (command === 'skills') {
    openSkillsModal(agentId);
    return;
  }

  try {
    const resp = await fetch(`/api/agent/${agentId}/${command}`, { method: 'POST' });
    if (resp.ok) {
      updateSpeechBubble(agentId, command === 'pause' ? 'Pausing...' : 'Resuming...');
      showToast(`${agentId.toUpperCase()} ${command.toUpperCase()}D`, 'success');
    } else {
      showToast(`${command.toUpperCase()} FAILED (${resp.status})`, 'error');
    }
  } catch (e) {
    console.error(`Failed to ${command} ${agentId}:`, e);
    showToast(`${command.toUpperCase()} FAILED — server offline?`, 'error');
  }
}

// ══════════════════════════════════════
// SKILLS MODAL
// ══════════════════════════════════════
let skillsCurrentAgent = null;
let skillsEditMode = false;

function initSkillsModal() {
  document.getElementById('skills-modal-close').addEventListener('click', () => {
    exitSkillsEditMode();
    document.getElementById('skills-modal').classList.remove('visible');
  });
  document.getElementById('skills-modal').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) {
      exitSkillsEditMode();
      e.currentTarget.classList.remove('visible');
    }
  });

  // EDIT button — switch to edit mode
  document.getElementById('skills-edit-btn').addEventListener('click', () => {
    const content = document.getElementById('skills-content');
    const editor = document.getElementById('skills-editor');
    editor.value = content.textContent;
    content.style.display = 'none';
    editor.style.display = 'block';
    document.getElementById('skills-edit-btn').style.display = 'none';
    document.getElementById('skills-save-btn').style.display = '';
    document.getElementById('skills-cancel-btn').style.display = '';
    skillsEditMode = true;
    editor.focus();
  });

  // CANCEL button — discard changes, back to read mode
  document.getElementById('skills-cancel-btn').addEventListener('click', () => {
    exitSkillsEditMode();
  });

  // SAVE button — POST to API, then back to read mode
  document.getElementById('skills-save-btn').addEventListener('click', async () => {
    if (!skillsCurrentAgent) return;
    const editor = document.getElementById('skills-editor');
    const status = document.getElementById('skills-save-status');
    const saveBtn = document.getElementById('skills-save-btn');

    saveBtn.textContent = '...';
    saveBtn.style.pointerEvents = 'none';

    try {
      const resp = await fetch(`/api/skills/${skillsCurrentAgent}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: editor.value }),
      });
      if (!resp.ok) throw new Error(`Save failed (${resp.status})`);

      // Update the read-mode content with saved text
      document.getElementById('skills-content').textContent = editor.value;
      exitSkillsEditMode();

      status.textContent = 'SAVED';
      status.style.color = '#27ae60';
      status.style.display = '';
      showToast(`${skillsCurrentAgent.toUpperCase()} SKILLS SAVED`, 'success');
      setTimeout(() => { status.style.display = 'none'; }, 2000);
    } catch (e) {
      status.textContent = `ERROR: ${e.message}`;
      status.style.color = '#e74c3c';
      status.style.display = '';
      showToast(`SAVE FAILED — ${e.message}`, 'error');
      setTimeout(() => { status.style.display = 'none'; }, 3000);
    } finally {
      saveBtn.textContent = 'SAVE';
      saveBtn.style.pointerEvents = '';
    }
  });
}

function exitSkillsEditMode() {
  if (!skillsEditMode) return;
  document.getElementById('skills-content').style.display = '';
  document.getElementById('skills-editor').style.display = 'none';
  document.getElementById('skills-edit-btn').style.display = '';
  document.getElementById('skills-save-btn').style.display = 'none';
  document.getElementById('skills-cancel-btn').style.display = 'none';
  skillsEditMode = false;
}

async function openSkillsModal(agentId) {
  const modal = document.getElementById('skills-modal');
  const tabs = document.getElementById('skills-tabs');
  const content = document.getElementById('skills-content');

  modal.classList.add('visible');
  content.textContent = 'Loading skills...';

  // Fetch available skills
  try {
    const resp = await fetch('/api/skills');
    if (!resp.ok) throw new Error('API not available');
    const data = await resp.json();

    tabs.innerHTML = data.skills.map(s => {
      const active = s.agent === agentId ? ' active' : '';
      return `<button class="modal-tab${active}" data-agent="${s.agent}">${(AGENT_NAMES[s.agent] || s.agent).toUpperCase()}</button>`;
    }).join('');

    tabs.querySelectorAll('.modal-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        loadSkillContent(tab.dataset.agent);
      });
    });

    await loadSkillContent(agentId);
  } catch (e) {
    // Fallback if API is not available
    tabs.innerHTML = '';
    content.textContent = 'Skills API not available. Start the dashboard server:\npython3 src/dashboard_server.py';
  }
}

async function loadSkillContent(agentId) {
  exitSkillsEditMode();
  skillsCurrentAgent = agentId;
  const content = document.getElementById('skills-content');
  try {
    const resp = await fetch(`/api/skills/${agentId}`);
    if (!resp.ok) throw new Error('Not found');
    const data = await resp.json();
    content.textContent = data.content || '(empty)';
  } catch (e) {
    content.textContent = `Failed to load skills for ${agentId}`;
  }
}

// ══════════════════════════════════════
// RENDERING — Agents & Collaborations
// ══════════════════════════════════════
function renderAgents(agents) {
  if (!agents || !agents.length) return;
  agents.forEach(a => updateAgent(a));
}

function escHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function sectionChanged(key, data) {
  if (!previousState) return true;
  return JSON.stringify(data[key]) !== JSON.stringify(previousState[key]);
}

function renderAll(data) {
  const safe = (fn, label) => { try { fn(); } catch(e) { console.error(`renderAll: ${label} failed:`, e); } };
  // Always render: title, live badge, agents (already incremental)
  safe(() => renderTitle(data), 'title');
  safe(() => updateLiveBadge(data.timestamp), 'liveBadge');
  safe(() => renderAgents(data.agents), 'agents');
  // Diff-gated sections — skip render if data unchanged
  if (sectionChanged('stats', data))           safe(() => renderTopStats(data.stats), 'topStats');
  if (sectionChanged('pipeline', data))        safe(() => renderPipeline(data.pipeline), 'pipeline');
  if (sectionChanged('queue_depths', data))    safe(() => renderQueueDepths(data.queue_depths), 'queueDepths');
  if (sectionChanged('now_processing', data))  safe(() => renderNowProcessing(data.now_processing), 'nowProcessing');
  if (sectionChanged('editor_inbox', data))    safe(() => renderInbox(data.editor_inbox), 'inbox');
  if (sectionChanged('log', data))             safe(() => renderLogWithFilters(data.log), 'log');
  if (sectionChanged('notable_finds', data))   safe(() => renderNotableFinds(data.notable_finds), 'notableFinds');
  if (sectionChanged('throughput', data))       safe(() => renderThroughput(data.throughput), 'throughput');
  if (sectionChanged('cost', data))             safe(() => renderCost(data.cost), 'cost');
  if (sectionChanged('quality', data))          safe(() => renderQuality(data.quality), 'quality');
  if (sectionChanged('collaborations', data))   safe(() => renderCollaborations(data.collaborations), 'collaborations');
  if (sectionChanged('editor_ledger', data))    safe(() => renderChalkboards(data.task_board, data.editor_ledger), 'chalkboards');
  if (sectionChanged('coverage_map', data))     safe(() => renderCoverageMap(data.coverage_map), 'coverageMap');
  previousState = data;
}

// ══════════════════════════════════════
// DEMO DATA
// ══════════════════════════════════════
const DEMO_DATA = {
  title: "AD-EPSTEIN INDEX \u2014 AGENT OFFICE",
  subtitle: "Architectural Digest research pipeline",
  timestamp: new Date().toISOString(),
  agents: [
    { id: "editor", name: "Miranda", status: "working", message: "Pipeline: GOOD — All systems operational", editor_state: "idle", errors: 0, paused: false },
    { id: "designer", name: "Sable", status: "idle", message: "Training mode — studying design patterns", errors: 0, paused: false },
    { id: "scout", name: "Arthur", status: "working", message: "Found 163 of 444 issues", errors: 0, paused: false },
    { id: "courier", name: "Casey", status: "working", message: "Downloading issue 31 of 163...", errors: 0, paused: false },
    { id: "reader", name: "Elias", status: "working", message: "Extracting features from Nov 2013", errors: 0, paused: false },
    { id: "detective", name: "Silas", status: "idle", message: "1 match found so far", errors: 0, paused: false },
    { id: "researcher", name: "Elena", status: "working", message: "Investigating Miranda Brooks...", errors: 0, paused: false }
  ],
  stats: [
    { label: "Discovered", value: 163, total: 444 },
    { label: "Downloaded", value: 75 },
    { label: "Extracted", value: 12 },
    { label: "Features", value: 89 },
    { label: "Matches", value: 1 },
    { label: "Dossiers", value: 3, popup_type: "dossiers", details: [
      { name: "Miranda Brooks", strength: "high", strength_rationale: "Direct match in Black Book...", editor_verdict: null, editor_reasoning: null },
      { name: "Isabel Goldsmith", strength: "low", strength_rationale: "Coincidental name overlap", editor_verdict: "REJECTED", editor_reasoning: "False positive" },
      { name: "Ghislaine Maxwell", strength: "high", strength_rationale: "Named associate", editor_verdict: "CONFIRMED", editor_reasoning: "Known associate" },
    ]},
    { label: "Confirmed", value: 1, popup_type: "confirmed", details: [
      { name: "Ghislaine Maxwell", strength: "high", rationale: "Named associate" },
    ]},
    { label: "Memories", value: 42, popup_type: "memories", details: [
      { agent: "scout", text: "Discovered AD Jan 2005 on archive.org via title search", outcome: "success", time: "10:32 PM" },
      { agent: "courier", text: "Downloaded architecturaldigest200501 (2005-01) from archive.org", outcome: "success", time: "10:30 PM" },
      { agent: "detective", text: "Cross-referenced Miranda Brooks against Black Book — exact match", outcome: "decision", time: "10:28 PM" },
    ]}
  ],
  pipeline: [
    { stage: "Discovered", agent: "scout", count: 163, total: 444, color: "#e74c3c" },
    { stage: "Downloaded", agent: "courier", count: 75, total: 163, color: "#3498db" },
    { stage: "Extracted", agent: "reader", count: 12, total: 75, color: "#2ecc71" },
    { stage: "Cross-Ref'd", agent: "detective", count: 1, total: 89, color: "#9b59b6" },
    { stage: "Investigated", agent: "researcher", count: 0, total: 1, color: "#e67e22" }
  ],
  queue_depths: [
    { label: "awaiting download", count: 87, color: "#3498db" },
    { label: "awaiting extraction", count: 63, color: "#2ecc71" },
    { label: "awaiting xref", count: 88, color: "#9b59b6" }
  ],
  now_processing: {
    editor: { task: "Pipeline GOOD — all agents active", active: true },
    scout: { task: "Found 163/444 (281 remaining)", active: true },
    courier: { task: "Downloading AD Mar 2005", active: true },
    reader: { task: "Extracting Nov 2013", active: true },
    detective: { task: "Checking Miranda Brooks", active: true },
    researcher: { task: "Building dossier — Miranda Brooks", active: true },
    designer: { task: "Training mode — studying design", active: false },
  },
  editor_inbox: [
    { time: "14:32", type: "status", text: "Pipeline health: GOOD. All 4 worker agents active. Courier at 46% download completion." },
    { time: "14:15", type: "alert", text: "First Epstein match found! Miranda Brooks appears in both AD Nov 2013 and the Black Book." },
    { time: "13:45", type: "status", text: "Reader extracted 8 features from Nov 2013. Quality looks strong — 77% name coverage." },
    { time: "13:00", type: "status", text: "Pipeline initialized. Scout found 163 of 444 expected issues on archive.org." },
  ],
  notable_finds: [
    { name: "Miranda Brooks", issue: "AD Nov 2013", location: "Connecticut", type: "epstein_match", status: "likely_match", research: "dossier_complete", research_detail: "high", editor_verdict: null },
    { name: "Isabel Goldsmith", issue: "AD Sep 2003", location: "Mexico City", type: "epstein_match", status: "possible_match", research: "investigating", research_detail: null, editor_verdict: null },
    { name: "Ghislaine Maxwell", issue: "AD Jan 2001", location: "New York", type: "epstein_match", status: "confirmed_match", research: "queued", research_detail: null, editor_verdict: null },
  ],
  quality: {
    total_features: 89,
    fields: [
      { label: "Names", filled: 69, total: 89, pct: 77 },
      { label: "Location", filled: 61, total: 89, pct: 69 },
      { label: "Designer", filled: 69, total: 89, pct: 77 },
      { label: "Year Built", filled: 34, total: 89, pct: 38 },
      { label: "Style", filled: 28, total: 89, pct: 31 },
      { label: "Sq Footage", filled: 22, total: 89, pct: 25 }
    ]
  },
  collaborations: [
    { from: "editor", to: "reader", type: "task_assign", label: "New extraction task" }
  ],
  log: [
    { time: "14:32", agent: "Courier", event: "Downloading AD March 2005..." },
    { time: "14:30", agent: "Reader", event: "Extracted 8 features from November 2013" },
    { time: "14:28", agent: "Detective", event: "Match found: Miranda Brooks (Black Book)" },
    { time: "14:25", agent: "Reader", event: "Extracted 6 features from October 2013" },
    { time: "14:20", agent: "Courier", event: "Downloaded AD issue #31" },
    { time: "14:15", agent: "Scout", event: "Discovery complete \u2014 163 issues indexed" },
    { time: "14:10", agent: "Courier", event: "Downloaded AD issue #30" },
    { time: "14:05", agent: "Reader", event: "Found George Clooney in Nov 2013" },
    { time: "14:00", agent: "Detective", event: "Checked 45 names, 1 match so far" }
  ],
  throughput: {
    downloads_per_hour: 4.5,
    extractions_per_hour: 1.2,
    eta_hours: 19.6,
  },
  cost: {
    api_calls: 47,
    input_tokens: 142000,
    output_tokens: 18500,
    total_cost: 0.1876,
  },
  task_board: {
    in_flight: [
      { id: 't1', agent: 'scout', type: 'discover_issues', goal: 'Find AD issues Jan-Mar 2015' },
      { id: 't2', agent: 'courier', type: 'download_pdf', goal: 'Download sim_ad_2005-03' },
      { id: 't3', agent: 'reader', type: 'extract_features', goal: 'Extract features from Nov 2013' },
      { id: 't4', agent: 'detective', type: 'cross_reference', goal: 'Check Miranda Brooks, Henri Samuel' },
    ],
    completed: [
      { id: 't5', agent: 'courier', type: 'download_pdf', goal: 'Downloaded sim_ad_2004-10' },
      { id: 't6', agent: 'reader', type: 'extract_features', goal: 'Extracted 8 features from Oct 2013' },
      { id: 't7', agent: 'scout', type: 'discover_issues', goal: 'Found 12 new issues on archive.org' },
    ],
    failed: [
      { id: 't8', agent: 'courier', type: 'download_pdf', goal: 'Download sim_ad_1995-03', error: '404 not found on archive.org' },
    ],
  },
  editor_ledger: {
    stuck: [
      { key: '2001-07', failures: 2, last_error: 'PDF corrupted, retry pending', agent: 'reader', task: 'extract_features' },
      { key: 'sim_ad_1999-11', failures: 1, last_error: 'Timeout on archive.org', agent: 'courier', task: 'download_pdf' },
    ],
    exhausted: [
      { key: 'sim_ad_1995-03', failures: 3, last_error: '404 not found on archive.org', agent: 'courier', task: 'download_pdf' },
      { key: '1992-05', failures: 3, last_error: 'No issue found for this month', agent: 'scout', task: 'discover_issues' },
    ],
    recent_failures: [
      { key: '2001-07', agent: 'reader', error: 'PDF corrupted, retry pending', time: '2026-02-09T14:30:00' },
      { key: 'sim_ad_1995-03', agent: 'courier', error: '404 not found', time: '2026-02-09T14:25:00' },
      { key: 'sim_ad_1999-11', agent: 'courier', error: 'Timeout on archive.org', time: '2026-02-09T14:20:00' },
      { key: '1992-05', agent: 'scout', error: 'No issue found', time: '2026-02-09T14:15:00' },
    ],
    total_keys: 18,
    total_failures: 9,
    total_successes: 34,
  },
  coverage_map: (() => {
    // Generate sample coverage map for demo
    const map = {};
    for (let y = 1988; y <= 2025; y++) {
      map[String(y)] = {};
      for (let m = 1; m <= 12; m++) {
        if (y < 1993) {
          // Early years: sparse discovery
          map[String(y)][String(m)] = Math.random() < 0.3 ? 'discovered' : null;
        } else if (y < 2000) {
          // Mid years: more discovered, some downloaded
          const r = Math.random();
          map[String(y)][String(m)] = r < 0.15 ? null : r < 0.4 ? 'discovered' : r < 0.7 ? 'downloaded' : 'extracted';
        } else if (y < 2015) {
          // 2000s: well covered
          const r = Math.random();
          map[String(y)][String(m)] = r < 0.05 ? null : r < 0.2 ? 'discovered' : r < 0.5 ? 'downloaded' : 'extracted';
        } else {
          // Recent: mostly discovered
          map[String(y)][String(m)] = Math.random() < 0.4 ? null : 'discovered';
        }
      }
    }
    return map;
  })(),
};

// ── Demo Animation Loop ──
let demoStep = 0;
function runDemoLoop() {
  if (!FORCE_DEMO) return;
  demoStep++;

  // Use the task-board-driven functions so board visits are visible
  switch (demoStep % 16) {
    case 1:
      editorAssignTask('reader', 'Extract features from Nov 2013');
      break;
    case 5:
      editorCollectResult('courier', 'Downloaded sim_ad_2004-10');
      break;
    case 9:
      editorAssignTask('scout', 'Find AD issues Jan-Mar 2015');
      break;
    case 13:
      editorHandleFailure('courier', '404 not found on archive.org');
      break;
  }
  setTimeout(runDemoLoop, 5000);
}

// ══════════════════════════════════════
// EDITOR BEHAVIOR SYSTEM
// ══════════════════════════════════════

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/** Hide all editor sprites, then show only the named one. */
function editorSetSprite(type) {
  const charEl = agentCharElements['editor'];
  if (!charEl) return;
  charEl.querySelectorAll('.char-img').forEach(img => img.style.display = 'none');
  const target = charEl.querySelector(`.char-${type}`);
  if (target) target.style.display = 'block';
}

/** Tap foot animation — alternates front/tap sprites. */
async function editorTapFoot() {
  if (editorBusy) return;
  editorBusy = true;
  const taps = 3 + Math.floor(Math.random() * 4); // 3–6 taps
  for (let i = 0; i < taps; i++) {
    editorSetSprite('tap');
    await sleep(300);
    editorSetSprite('front');
    await sleep(300);
  }
  editorBusy = false;
}

/** Quick blink — brief swap to blink sprite and back. */
async function editorBlink() {
  editorSetSprite('blink');
  await sleep(150);
  if (!editorBusy) editorSetSprite('front');
}

/** Check watch — show watch sprite for a couple seconds. */
async function editorCheckWatch() {
  if (editorBusy) return;
  editorBusy = true;
  editorSetSprite('watch');
  updateSpeechBubble('editor', 'Hmm, checking the time...');
  await sleep(2500);
  editorSetSprite('front');
  editorBusy = false;
}

/** Patrol — walk up the center aisle and back. */
async function editorPatrol() {
  if (editorBusy) return;
  editorBusy = true;
  const cfg = AGENT_CONFIG.editor;

  // Walk up the center aisle
  await walkEditorTo(50, 45, { finalSprite: 'back' });

  // Pause at top
  await sleep(1200);

  // Walk back down
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Study the boards — walk to each chalkboard, study them, return to center. */
async function editorStudyBoards() {
  if (editorBusy) return;
  editorBusy = true;
  const cfg = AGENT_CONFIG.editor;

  // Walk to Editor's Board (left chalkboard) via aisle
  updateSpeechBubble('editor', 'Let me check the board...');
  await walkEditorTo(BOARD_LEFT_POS.x, BOARD_LEFT_POS.y);

  // Study the board
  editorSetSprite('studying');
  updateSpeechBubble('editor', 'Reviewing assignments...');
  await sleep(3000);

  // Walk to Completed/Failed board (right chalkboard) — same row, horizontal
  await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y);

  editorSetSprite('studying');
  updateSpeechBubble('editor', 'Checking results...');
  await sleep(2500);

  // Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Visit a specific agent — walk to their row, yellow glow exchange, return. */
async function editorVisitAgent(agentId) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;

  // Yellow glow on both Editor and target agent (hub-and-spoke engagement)
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }

  // Agent steps toward aisle to meet Editor
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk toward agent's row via center aisle
  await walkEditorTo(50, target.homeY);

  // Turn to face the agent and interact
  editorSetSprite('front');
  updateSpeechBubble('editor', `Checking in with ${agentId}...`);
  await sleep(2000);

  // Clear engagement glow
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');

  // Agent returns to desk
  moveAgentHome(agentId);

  // Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });
  editorBusy = false;
}

/** Gather reports — visit all workers in sequence (triggered by working status). */
let lastGatherTime = 0;
async function editorGatherReports() {
  if (editorBusy) return;
  // Cooldown: don't gather more than once every 90 seconds
  const now = Date.now();
  if (now - lastGatherTime < 90000) return;
  lastGatherTime = now;
  editorBusy = true;

  const workers = ['scout', 'courier', 'reader', 'detective'];
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];

  updateSpeechBubble('editor', 'Time for status reports!');
  await sleep(1000);

  for (const agentId of workers) {
    const target = AGENT_CONFIG[agentId];
    if (!target) continue;

    // Yellow glow on both Editor and target agent
    const targetChar = agentCharElements[agentId];
    if (editorChar) editorChar.classList.add('editor-engage');
    if (targetChar) {
      targetChar.classList.remove('hub-working', 'hub-waiting');
      targetChar.classList.add('editor-engage', 'show-front');
    }

    // Agent steps toward aisle
    moveAgentTo(agentId, target.exitX, target.homeY, true);

    // Walk toward this agent's row
    const goingUp = target.homeY < cfg.homeY;
    editorSetSprite(goingUp ? 'back' : 'front');
    moveAgentTo('editor', 50, target.homeY, !goingUp);
    if (goingUp) editorSetSprite('back');
    await sleep(1500);

    // Interact
    editorSetSprite('front');
    updateSpeechBubble('editor', `Report, ${agentId}?`);
    await sleep(1500);

    // Clear engagement glow, agent returns to desk
    if (editorChar) editorChar.classList.remove('editor-engage');
    if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
    moveAgentHome(agentId);
  }

  // Return home
  editorSetSprite('front');
  moveAgentTo('editor', cfg.homeX, cfg.homeY, true);
  editorSetSprite('front');
  await sleep(1500);

  updateSpeechBubble('editor', 'All reports collected!');
  editorBusy = false;
}

/** Start the editor's task-board-driven behavior loop + background blinks. */
function initEditorBehavior() {
  scheduleEditorBehavior();
  scheduleEditorBlinks();
}

/** Schedule the next behavior check. Faster when there are queued events. */
function scheduleEditorBehavior() {
  const hasQueue = _editorActionQueue.length > 0;
  const delay = hasQueue
    ? 3000 + Math.random() * 3000    // 3-6s when events to process
    : 25000 + Math.random() * 20000; // 25-45s when idle
  editorBehaviorTimer = setTimeout(doEditorBehavior, delay);
}

// ── Task Board Diff System ──
// Tracks previous task_board snapshot to detect new assignments, completions, failures
let _prevTaskBoard = { in_flight: [], completed: [], failed: [] };
let _editorActionQueue = []; // { type: 'assign'|'collect'|'failure', agent, label }

/** Compare current task_board to previous snapshot. Queue editor actions for changes. */
function diffTaskBoard() {
  if (!currentState?.task_board) return;
  const board = currentState.task_board;

  const prevInFlight = new Set((_prevTaskBoard.in_flight || []).map(t => t.id || t.task_id));
  const prevCompleted = new Set((_prevTaskBoard.completed || []).map(t => t.id || t.task_id));
  const prevFailed = new Set((_prevTaskBoard.failed || []).map(t => t.id || t.task_id));

  // New tasks in flight = Editor assigned work
  for (const task of (board.in_flight || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevInFlight.has(tid)) {
      const agent = task.agent || task.assigned_to || '';
      _editorActionQueue.push({
        type: 'assign',
        agent: agent,
        label: task.goal || task.type || 'New task',
      });
    }
  }

  // New completed tasks = Editor collecting results
  for (const task of (board.completed || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevCompleted.has(tid)) {
      const agent = task.agent || task.completed_by || '';
      _editorActionQueue.push({
        type: 'collect',
        agent: agent,
        label: task.goal || task.type || 'Task complete',
      });
    }
  }

  // New failed tasks = Editor responding to failure
  for (const task of (board.failed || [])) {
    const tid = task.id || task.task_id;
    if (tid && !prevFailed.has(tid)) {
      const agent = task.agent || task.failed_by || '';
      _editorActionQueue.push({
        type: 'failure',
        agent: agent,
        label: task.error || task.goal || 'Task failed',
      });
    }
  }

  // Cap queue to prevent runaway if many events arrive at once
  if (_editorActionQueue.length > 6) {
    _editorActionQueue = _editorActionQueue.slice(-6);
  }

  _prevTaskBoard = JSON.parse(JSON.stringify(board));
}

/** Editor walks to board, picks up task, then walks to agent to assign it. */
async function editorAssignTask(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Step 1: Walk to Editor's Board via aisle to pick up the assignment
  await walkEditorTo(BOARD_LEFT_POS.x, BOARD_LEFT_POS.y);

  editorSetSprite('clipboard');
  updateSpeechBubble('editor', 'New assignment...');
  await sleep(1500);

  // Step 2: Yellow glow on both — agent steps to aisle
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }
  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Step 3: Walk from board to agent's row via aisle with clipboard
  await walkEditorTo(50, target.homeY, { carrySprite: 'clipboard' });

  // Step 4: Face agent, deliver task
  editorSetSprite('front');
  updateSpeechBubble('editor', label);
  await sleep(2500);

  // Step 5: Clear engagement, agent returns
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
  moveAgentHome(agentId);

  // Step 6: Walk back home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Editor walks to agent to collect a result (returns happy). */
async function editorCollectResult(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  if (soundOn) playCollabSound();

  // Yellow glow
  if (editorChar) editorChar.classList.add('editor-engage');
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done');
    targetChar.classList.add('editor-engage', 'show-front');
  }

  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk to agent via aisle (empty-handed)
  await walkEditorTo(50, target.homeY);

  // Collect and show happy face
  editorSetSprite('happy');
  updateSpeechBubble('editor', 'Good work!');
  await sleep(2000);

  // Clear engagement
  if (editorChar) editorChar.classList.remove('editor-engage');
  if (targetChar) targetChar.classList.remove('editor-engage', 'show-front');
  moveAgentHome(agentId);

  // Walk to Completed board (right chalkboard) via aisle to log the result
  await walkEditorTo(BOARD_RIGHT_POS.x, BOARD_RIGHT_POS.y, { carrySprite: 'clipboard' });

  editorSetSprite('clipboard');
  updateSpeechBubble('editor', 'Logging result...');
  await sleep(1800);

  // Walk home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Editor walks to agent to respond to a failure (concerned face, red glow). */
async function editorHandleFailure(agentId, label) {
  if (editorBusy) return;
  editorBusy = true;

  const target = AGENT_CONFIG[agentId];
  if (!target) { editorBusy = false; return; }
  const cfg = AGENT_CONFIG.editor;
  const editorChar = agentCharElements['editor'];
  const targetChar = agentCharElements[agentId];

  // Red-tinted glow for failure (override yellow)
  if (editorChar) {
    editorChar.classList.add('collab-glow');
    editorChar.style.setProperty('--glow-color', '#e74c3c');
  }
  if (targetChar) {
    targetChar.classList.remove('hub-working', 'hub-waiting', 'hub-bored', 'hub-done');
    targetChar.classList.add('collab-glow', 'show-front');
    targetChar.style.setProperty('--glow-color', '#e74c3c');
  }

  moveAgentTo(agentId, target.exitX, target.homeY, true);

  // Walk to agent via aisle
  await walkEditorTo(50, target.homeY);

  // Show failure/concerned face
  editorSetSprite('failure');
  updateSpeechBubble('editor', 'Let\u2019s try a different approach...');
  await sleep(2500);

  // Clear glow
  if (editorChar) { editorChar.classList.remove('collab-glow'); editorChar.style.removeProperty('--glow-color'); }
  if (targetChar) { targetChar.classList.remove('collab-glow', 'show-front'); targetChar.style.removeProperty('--glow-color'); }
  moveAgentHome(agentId);

  // Walk to Editor's Board (left chalkboard) via aisle to log the failure
  await walkEditorTo(BOARD_LEFT_POS.x, BOARD_LEFT_POS.y, { carrySprite: 'clipboard' });

  editorSetSprite('clipboard');
  updateSpeechBubble('editor', 'Logging failure...');
  await sleep(1800);

  // Walk home via aisle
  await walkEditorTo(cfg.homeX, cfg.homeY, { finalSprite: 'front' });

  editorBusy = false;
}

/** Pick and execute editor behavior based on task board events. */
async function doEditorBehavior() {
  if (editorBusy) {
    scheduleEditorBehavior();
    return;
  }

  // Diff the task board for new events
  diffTaskBoard();

  if (_editorActionQueue.length > 0) {
    const action = _editorActionQueue.shift();
    const agentId = action.agent?.toLowerCase();

    // Only visit if we know this agent
    if (agentId && AGENT_CONFIG[agentId] && agentId !== 'editor') {
      switch (action.type) {
        case 'assign':
          await editorAssignTask(agentId, action.label);
          break;
        case 'collect':
          await editorCollectResult(agentId, action.label);
          break;
        case 'failure':
          await editorHandleFailure(agentId, action.label);
          break;
      }
    }
  } else {
    // No task board events — check editor_state for strategic assessment
    const editorState = currentState?.agents?.find(a => a.id === 'editor')?.editor_state;
    if (editorState === 'assessing') {
      // Strategic assessment: walk to boards and study them
      await editorStudyBoards();
    } else {
      // True idle: subtle animations
      const roll = Math.random();
      if (roll < 0.25) {
        await editorTapFoot();
      } else if (roll < 0.45) {
        await editorCheckWatch();
      } else if (roll < 0.70) {
        // Walk to chalkboards and study them
        await editorStudyBoards();
      } else {
        // Occasional patrol up the aisle and back
        await editorPatrol();
      }
    }
  }

  scheduleEditorBehavior();
}

/** Schedule random blinks independent of main behavior. */
function scheduleEditorBlinks() {
  const delay = 3000 + Math.random() * 5000; // 3–8 seconds
  setTimeout(async () => {
    if (!editorBusy) {
      await editorBlink();
    }
    scheduleEditorBlinks();
  }, delay);
}

// ── Fetch & Poll ──
async function fetchStatus() {
  if (FORCE_DEMO) {
    DEMO_DATA.timestamp = new Date().toISOString(); // Keep demo "live"
    dataSource = 'demo';
    currentState = DEMO_DATA;
    renderAll(DEMO_DATA);
    if (demoStep === 0) setTimeout(runDemoLoop, 3000);
    return;
  }

  try {
    const resp = await fetch(STATUS_URL + '?t=' + Date.now());
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    dataSource = 'live';
    currentState = data;
    lastDataTimestamp = data.timestamp;
    renderAll(data);
  } catch (e) {
    try {
      const demoResp = await fetch('demo-status.json?t=' + Date.now());
      if (demoResp.ok) {
        const demoData = await demoResp.json();
        dataSource = 'live'; // demo-status.json is still "real" data
        currentState = demoData;
        lastDataTimestamp = demoData.timestamp;
        renderAll(demoData);
        return;
      }
    } catch (_) {}
    console.log('Using built-in demo data:', e.message);
    if (dataSource !== 'demo') showToast('SERVER OFFLINE — using demo data', 'info', 4000);
    dataSource = 'demo';
    DEMO_DATA.timestamp = new Date().toISOString();
    currentState = DEMO_DATA;
    renderAll(DEMO_DATA);
  }
}

// ── Sound ──
function initSound() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function toggleSound() {
  const btn = document.getElementById('sound-toggle');
  soundOn = !soundOn;
  if (soundOn) {
    if (!audioCtx) initSound();
    btn.textContent = 'SFX ON';
    btn.classList.add('active');
    startAmbient();
  } else {
    btn.textContent = 'SFX OFF';
    btn.classList.remove('active');
    stopAmbient();
  }
}
function startAmbient() {
  if (!audioCtx || ambientOsc) return;
  ambientOsc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  ambientOsc.type = 'sine'; ambientOsc.frequency.value = 80;
  gain.gain.value = 0.02;
  ambientOsc.connect(gain); gain.connect(audioCtx.destination);
  ambientOsc.start();
}
function stopAmbient() {
  if (ambientOsc) { ambientOsc.stop(); ambientOsc = null; }
}
function playCollabSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(330, audioCtx.currentTime);
  osc.frequency.linearRampToValueAtTime(660, audioCtx.currentTime + 0.15);
  gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.2);
}

// ── Scale to fit window ──
function scaleDashboard() {
  const el = document.querySelector('.dashboard');
  const scaleX = window.innerWidth / 1920;
  const scaleY = window.innerHeight / 1080;
  const scale = Math.min(scaleX, scaleY);
  el.style.transform = `scale(${scale})`;
  // Sync left panel bottom with office scene bottom
  requestAnimationFrame(syncPanelHeight);
}
function syncPanelHeight() {
  const wrapper = document.querySelector('.office-scene-wrapper');
  const leftPanel = document.querySelector('.panel-left');
  if (wrapper && leftPanel) {
    // Use offsetHeight — unaffected by CSS transform scale
    leftPanel.style.maxHeight = wrapper.offsetHeight + 'px';
  }
}
scaleDashboard();
window.addEventListener('resize', scaleDashboard);

// ── Init ──
init();
</script>
</body>
</html>
